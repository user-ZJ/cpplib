# linux性能优化笔记

**系统负载**：指正在运行和可运行的进程（线程）总数，如正在运行的进程（线程）为2个，可运行进程（线程）为3个，那么系统负载为5

**平均负载**：给定时间内的负载量，一般情况下取平均负载的时间为1分钟，5分钟，15分钟

### linux优先级

程序的优先级范围为[0,139]，有效的实时优先级（RT priority）范围为[0,99]，非实时任务的优先级为[100,139]，[100,139]这个区间的优先级又称为静态优先级(static priority)。

之所以称为静态优先级是因为它不会随着时间而改变，内核不会修改它，只能通过系统调用nice去修改。静态优先级用进程描述符中的static_prio表示。优先级的值越低，表示具有更高的优先级

用户的nice值[-20,19]对应于静态优先级的[100,139]，也就是说，nice值越小，优先级越低。用户的nice值与优先级的转化关系为

```cpp
//DEFAULT_PRIO的值为120，对应的nice值为0
#define NICE_TO_PRIO(nice)      ((nice) + DEFAULT_PRIO)
#define PRIO_TO_NICE(prio)      ((prio) - DEFAULT_PRIO)
```

一个进程可以间接地通过使用进程的nice级别来改变静态优先级。

 top中的PR表示优先级，在top中，实时优先级的[0,99]没有具体的表示，统一用RT来表示。而静态优先级和top中的优先级关系为`top_PR = static_Priority - 100`也就是说，top中的PR取值为[0,39]，对应图1的优先级[100,139]

 ps中的PRI也是表示优先级，通过`ps -el`可以显示出来，`ps_PRI = static_priority - 40`

### 系统CPU监控工具

vmstat；top；procinfo；mpstat；sar；oprofile

### 系统内存监控工具

vmstat；top；procinfo；free；slabtop；sar；/procmeminfo

### 特定进程CPU监控工具

time；strace；ltrace；ps；ld.so；gprof；oprofile

### 特定进程内存统计工具

ps；/proc/；memprof；valgrind(cachegrind)；kcachegrind；oprofile；ipcs

### 磁盘IO监控工具

vmstat；iostat；sar；lsof；iotop

### 网络监控工具

mii-tool；ethtool；ifconfig；ip；sar；gkrellm；iptraf；netstat；etherape

## 1 vmstat

vmstat能够获取整个系统性能的粗略信息，包括

* 正在运行的进程个数
* CPU使用情况
* CPU接收中断个数
* 调度器执行的上下文切换次数

```shell
vmstat [-n] [-s] [delay [count]]
```

vmstat运行于两种模式：采样模式和平均模型。如果不指定参数，vmstat统计运行在平均模式下；如果指定了延迟，则运行在采样模式

平均模式显示系统启动以来所有统计数据的均值

采样模式第一个采样点仍然是系统启动以来的均值，但之后vmstat按照延迟秒数采样系统并显示统计数据

### 参数

| 选项            | 说明                                                                                                  |
| ------------- | --------------------------------------------------------------------------------------------------- |
| -n            | 默认情况下vmstat定期显示每个性能统计数据的列标题。<br />加-n选项，只在运行vmstat时打印一次列标题，如果要导出电子表格，使用-n选项比较友好                     |
| -s            | 一次性输出vmstat收集的系统统计详细信息。该信息为系统启动后的总数据                                                                |
| delay [conut] | vmstat采样间隔时间；<br />vmstat 5  每隔5s采样一次，会一直采样<br />vmstat 5 10  每隔5s采样一次，总共采样10次后停止                   |
| -t            | 显示时间戳                                                                                               |
| -a            | 内存选项；改变内存统计信息的默认输出以表示活跃/非活跃内存量，而不是缓冲区和高速缓存使用情况的信息                                                   |
| -m            | 内存选项；输出内核分片信息。cat /proc/slabinfo可以获得同样的信息。详细展示了内核内存是如何分配的，并有助于确定哪部分内核消耗内存最多                         |
| -D            | IO选项；显示Linux IO子系统总的统计数据。它可以让你很好的了解你的IO子系统是如何被使用的，但它不会给出单个磁盘的统计数据。显示的统计数据是从系统启动开始的总信息，而不是两次采样之间的发生量 |
| -d            | IO选项；按每interval一个样本的速率显示单个磁盘的统计数据。这些统计信息是从系统启动开始的总信息，而不是两次采样之间的发生量                                  |
| -p partition  | IO选项；按每interval一个样本的速率显示给定分区的性能统计数据。这些统计信息是从系统启动开始的总信息，而不是两次采样之间的发生量                                |

### 输出信息

**CPU相关信息**

| 列     | 说明                                               |
| ----- | ------------------------------------------------ |
| r     | 当前可运行的进程数，这些进程没有等待IO，而是已经准备好运行                   |
| b     | 等待IO完成的被阻塞的进程数                                   |
| in    | 系统发生中断的次数                                        |
| cs    | 系统发生上下文切换的次数                                     |
| us    | 用户进程消耗的总CPU时间的百分比（包括“友好的”时间）                     |
| sy    | 系统代码消耗的总CPU时间的百分比，其中包括消耗在system、irq和softirq状态的时间 |
| wa    | 等待IO消耗的总CPU时间的百分比                                |
| id    | 系统空闲消耗总CPU时间的百分比                                 |
| forks | 创建新进程的次数                                         |

**内存相关信息**

| 列                 | 说明                                                                                        |
| ----------------- | ----------------------------------------------------------------------------------------- |
| swpd              | 当前交换到硬盘的内存总量                                                                              |
| free              | 未被操作系统或应用程序使用的物理内存总量                                                                      |
| buff              | 系统缓冲区大小（单位为KB），或用于存放等待保存到硬盘的数据的内存大小（单位为KB）。该存储区允许应用程序向linux内核发出写调用后立即继续执行，而不是等待直到数据被提交到磁盘 |
| cache             | 用于保存之前从硬盘读取的数据的系统高速缓存或内存的大小（单位为KB）。如果应用程序再次需要该数据，内核可以从内存而非硬盘抓取数据，由此可提高性能                  |
| activate          | 被使用的活跃内存量。活跃/不活跃的统计数据与缓冲区/高速缓存是正交的；缓冲区和高速缓存可以是活跃的，也可以是不活跃的                                |
| inactivate        | 不活跃的内存总量（单位为KB），或一段时间未被使用，适合交换到硬盘的内存量                                                     |
| si                | 上一次采样中，从硬盘进来的内存交换速率（单位为KB/s）                                                              |
| so                | 上一次采样中，到硬盘去的内存交换速率（单位为KB/s）                                                               |
| pages paged in    | 从硬盘读入系统缓冲区的内存总量（单位为页）                                                                     |
| pages paged out   | 从系统高速缓存写到硬盘的内存总量（单位为页）                                                                    |
| pages swapped in  | 从交换分区读入系统内存的内存总量（单位为页）                                                                    |
| pages swapped out | 从系统内存写到交换分区的内存总量（单位为页）                                                                    |
| used swap         | linux内核目前正在使用的交换分区容量                                                                      |
| free swap         | 当前可用交换分区容量                                                                                |
| total swap        | 系统的交换分区总量                                                                                 |

**IO相关信息**

| 列               | 说明                                        |
| --------------- | ----------------------------------------- |
| bo              | 前次间隔中被写入磁盘的总块数（vmstat内磁盘的典型块大小为1024字节）    |
| bi              | 前次间隔中从磁盘读出的总块数（vmstat内磁盘的典型块大小为1024字节）    |
| wa              | 等待IO完成所消耗的CPU时间。                          |
| disks           | -D模式 ;系统中的磁盘总数                            |
| partitions      | -D模式 ;系统中的分区总数                            |
| total reads     | -D模式 ;读请求总数                               |
| merged reads    | -D模式 ;为了提升性能而被合并的不同请求数量，这些读请求访问的是磁盘上的相邻位置 |
| read sectors    | -D模式 ;从磁盘中读取的扇区总数（一个扇区通常为512字节）           |
| milli reading   | -D模式 ;磁盘读所花费的时间（以毫秒为单位）                   |
| writes          | -D模式 ;写请求的总数                              |
| merged writes   | -D模式 ;为了提升性能而被合并的不同请求数量，这些请求访问的是磁盘上的相邻位置  |
| written sectors | -D模式 ;向磁盘写入的扇区总数（一个扇区通常为512字节）            |
| milli writing   | -D模式 ;磁盘写所花费的时间（以毫秒为单位）                   |
| inprogress IO   | -D模式 ;当前正在处理的IO总数。                        |
| milli spent IO  | -D模式 ;等待IO所花费的毫秒数                         |
| reads:total     | -d模式 ;读请求的总数                              |
| reads：merged    | -d模式 ;为了提升性能而被合并的不同请求数量，这些读请求访问的是磁盘上的相邻位置 |
| reads：sectors   | -d模式 ;从磁盘中读取的扇区总数（一个扇区通常为512字节）           |
| reads：ms        | -d模式 ;磁盘读所花费的时间（以毫秒为单位）                   |
| writes：total    | -d模式 ;写请求的总数                              |
| writes：merged   | -d模式 ;为了提升性能而被合并的不同请求数量，这些请求访问的是磁盘上的相邻位置  |
| writes：sectors  | -d模式 ;向磁盘写入的扇区总数（一个扇区通常为512字节）            |
| writes：ms       | -d模式 ;磁盘写所花费的时间（以毫秒为单位）                   |
| IO：cur          | -d模式 ;当前正在处理的IO总数。                        |
| IO：s            | -d模式 ;等待IO所花费的秒数                          |

## 2 top

top是linux系统监控工具中的瑞士军刀。它善于将相当多的系统整体性能放在一个屏幕上。显示内容还能以交互的方式进行改变。默认情况下top将占用CPU最多的进程按照降序排列，每3秒刷新一次。

```shell
top -hv | -bcHiOSs -d secs -n max -u|U user -p pid(s) -o field -w [cols]
```

### 参数

| 选项                    | 说明                                                                                                             |
| --------------------- | -------------------------------------------------------------------------------------------------------------- |
| -h \|-v               | Help/Version，帮助信息和版本信息                                                                                         |
| -b                    | 以批处理模型运行。通常top只显示单屏信息，超出该屏幕的进程不显示。该选项显示全部进程。如果你要将top的输出保存为文件或输出给另一个命令处理，那么该项是很有用的<br />可以配合-n一起使用，如top -b -n 1 |
| -n iterations         | 退出前迭代的次数。不使用该参数则会一直刷新下去                                                                                        |
| -d delay              | 更新的时间间隔                                                                                                        |
| -i                    | 不显示空闲进程                                                                                                        |
| -c                    | 显示进程的完整名称                                                                                                      |
| -H                    | 线程模式。top 显示单个线程。 如果没有此命令行选项，则会显示每个进程中所有线程的总和。 稍后可以使用“H”交互命令更改此设置                                               |
| -o fieldname          | 指定排序的列。<br />top -o +%CPU   按CPU占用率从高到底排序<br />top -o -%CPU    按CPU占用率从低到高排序                                   |
| -O                    | 输出所有列名，可以帮助-o选项选择对应的列                                                                                          |
| -p pid1 pid2          | 监控指定pid的进程，最多可指定20个pid                                                                                         |
| -s                    | 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。                                                                               |
| -S                    | 累计时间，当累积时间模式为 On 时，每个进程都会列出它及其死子进程使用的 CPU 时间                                                                   |
| -u\|-U number or name | 只显示指定用户的进程                                                                                                     |
| -w number             | 指定每行的宽度                                                                                                        |

### 运行时选项

**全局交互命令**

| 命令             | 说明                                                                                                     |
| -------------- | ------------------------------------------------------------------------------------------------------ |
| Enter or Space | 刷新显示                                                                                                   |
| ? \|h          | 帮助信息                                                                                                   |
| =              | 退出任务限制。取消对显示的筛选操作，如top -i                                                                              |
| 0(数字0)         | 零抑制，即不显示0                                                                                              |
| A              | 交替显示模式。进程的另一种显示方式，其内容为各种系统资源最大的消耗者                                                                     |
| B              | 粗体禁用/启用                                                                                                |
| d \|s  *       | 更改刷新时间间隔                                                                                               |
| E              | 修改summary区域内存显示尺度（K/M/G）                                                                               |
| e              | 修改task区域（进程）内存显示尺度（K/M/G）                                                                              |
| g              | 选择另一个窗口/字段组                                                                                            |
| H              | 线程模式                                                                                                   |
| I（大写i）         | Irix mode;top是否用系统中的CPU数量除以CPU使用率<br />例如一个系统中有两个CPU，如果一个进程占用了这两个CPU，那么这个选项将在top显示CPU使用率为100%或200%之间切换 |
| k pid          | kill 一个进程                                                                                              |
| q              | 退出                                                                                                     |
| r pid nice     | 调整进程的优先级（NI列），进程优先级为-20-19；-20最高，19最低。普通用户只能从高优先级往低优先级调整                                               |

**SUMMARY区域交互命令**

| 选项     | 说明                                                                                                                               |
| ------ | -------------------------------------------------------------------------------------------------------------------------------- |
| l(小写L) | 隐藏系统启动时间和load average 行                                                                                                          |
| t      | 修改task行和CPU行显示，在1,2,3,4之间循环切换<br />1. 按类别划分的详细百分比<br />2. 简略的CPU占用百分比+bar图形显示<br />3. 简略的CPU占用百分比+block图形显示<br />4. 不显示CPU和TASK行 |
| m      | Memory/Swap的显示切换<br />1. 显示Memory/Swap详细信息<br />2. 显示内存占用百分比/总内存+bar图形显示<br />3. 显示内存占用百分比/总内存+block图形显示<br />4. 关闭显示            |
| 1（数字）  | 切换CPU使用率，是按照独立使用率显示还是按照总量显示                                                                                                      |

**TASK区域交互命令**

| 选项     | 说明                                         |
| ------ | ------------------------------------------ |
| J/j    | 切换左、右对齐                                    |
| x      | 高亮排序的列                                     |
| c      | 是否显示进程的完整名称                                |
| f/F    | 添加、删除要显示的列                                 |
| S      | 累计时间模式。<br />开启时，显示进程及dead子进程CPU占用时间之和的百分比 |
| u \| U | 显示指定用户的进程                                  |
| V      | tree视图，显示父子进程之间的关系                         |
| i      | 不显示空闲进程                                    |
| n \| # | 限制显示进程的个数                                  |
| < \| > | 左右切换需要排序的列；配合x高亮排序的列可以更明显的观察               |
| R      | 从大到小排序切换到从小到大排序                            |

### 输出信息

**CPU相关信息**

| 选项           | 说明                                                           |
| ------------ | ------------------------------------------------------------ |
| us           | 用户应用程序消耗的CPU时间                                               |
| sy           | 内核消耗的CPU时间                                                   |
| ni           | 修改过NI(优先级)的进程消耗的CPU时间                                        |
| id           | 空闲的CPU时间                                                     |
| wa           | 等待IO的CPU时间                                                   |
| hi           | irq处理程序消耗的CPU时间                                              |
| si           | softirq处理程序消耗的CPU时间                                          |
| load average | 1分钟、5分钟和15分钟的平均负载                                            |
| %CPU         | 特定进程消耗的CPU时间                                                 |
| PR           | 进程优先级，值越小优先级越高。top_PR = static_Priority - 100                |
| NI           | 进程的nice值。nice值越高，系统执行该进程的必要性就越低。static_priority = nice + 120 |
| WCHAN        | 若进程在等待IO，该项显示其等待的是哪个内核函数                                     |
| TIME         | 自进程开始执行起已消耗的总的CPU时间（用户和系统）                                   |
| COMMAND      | 进程执行的命令                                                      |
| S            | 进程当前的状态。睡眠状态（S),运行状态（R），僵尸状态（Z），不可中断的睡眠状态（D），跟踪状态（T）         |

**内存相关信息**

| 选项                             | 说明                                                                                          |
| ------------------------------ | ------------------------------------------------------------------------------------------- |
| %MEM                           | 进程使用内存占系统物理内存的百分比                                                                           |
| VIRT                           | 进程虚拟内存使用总量。其中包括应用程序分配但未使用的全部内存                                                              |
| RES                            | 应用程序实际使用的物理内存总量                                                                             |
| SHR                            | 可与其他进程共享的内存总量                                                                               |
| CODE                           | 进程的可执行代码使用的物理内存总量                                                                           |
| SWAP                           | 进程使用的交换区总量                                                                                  |
| nDRT                           | 需要刷新到硬盘的脏页面的数量                                                                              |
| Mem total,free,used,buff/cache | 对于物理内存来说，表示其总量，空闲量，使用量，缓冲区量                                                                 |
| Swap total,free,used,avail mem | 对于交换分区来说，表示其总量，空闲量，使用量<br />avail mem表示可用于启动新应用程序的物理内存估计，不包含swap，和free不同的是，它考虑易于回收的页面缓存和内存块 |

## 3. procinfo

procinfo为系统整体性能提供总览

```shell
procinfo [-sidDSbhHv] [-nN]
```

### 参数

| 选项  | 说明                                                |
| --- | ------------------------------------------------- |
| -nN | 全屏运行procinfo，每N秒更新一次                              |
| -d  | 显示样本统计信息的变化，而非总和                                  |
| -D  | 显示统计信息的总和，而非变化率                                   |
| -S  | with -nN and -d/-D, always show values per second |
| -b  | 显示字节数而不是IO请求数                                     |

### 输出信息

**CPU相关信息**

| 选项     | 说明                       |
| ------ | ------------------------ |
| user   | CPU花费的总用户时间，形式为天、小时和分钟   |
| nice   | CPU花费的总nice时间，形式为天、小时和分钟 |
| system | CPU花费的总系统时间，形式为天、小时和分钟   |
| IOwait | CPU花费的总IO等待时间，形式为天、小时和分钟 |
| idle   | CPU花费的总空闲时间，形式为天、小时和分钟   |
| uptime | 系统运行时间                   |

**内存相关信息**

| 选项       | 说明                 |
| -------- | ------------------ |
| Total    | 物理内存总量             |
| Use      | 使用的物理内存总量          |
| Free     | 空闲的物理内存总量          |
| Buffers  | 用于硬盘写缓冲区的物理内存总量    |
| Page in  | 从硬盘读入的块数（通常大小为1KB） |
| Page out | 写入硬盘的块数（通常大小为1KB）  |
| Swap in  | 从交换分区读入的内存页数       |
| Swap out | 写到交换分区的内存页数        |

## 4. gnome-system-monitor

gnome-system-monitor在很多方面可以说是top的图形化，它能使你以图形方式监控各个进程，并在显示图表的基础上观察系统负载

## 5. mpstat(多处理器统计)

mpstat最大的优点是在统计信息的旁边显示时间，由此可以找出CPU使用率和时间的关系。

如果有多个CPU或超线程CPU，mpstat还能把CPU使用率按处理器进行区分，因此你可以发现与其他处理器相比，是否某个处理器做了更多的工作。可以选择想要监控的单个处理器，也可以要求mpstat对所有处理器进行监控。

mpstat可以用来确定CPU是否得到充分利用，以及是否相对均衡；通过观察每个CPU处理的中断数，有可能发现其中的不均衡。

```shell
mpstat [ options ] [ <interval> [ <count> ] ]
# 常用
mpstat 1 100
mpstat -P ALL 1
```

### 参数

| 选项                         | 说明                                                                       |
| -------------------------- | ------------------------------------------------------------------------ |
| -P { cpu_list \|ON \|ALL } | 指定要监控的CPU<br />cpu_list 0,2,4-7,12-<br />ON对所有在线的CPU进行监控；ALL表示对所有CPU进行监控 |
| interval  [ count ]        | 间隔interval秒刷新一次，count表示退出前刷新次数                                           |
| -o JSON                    | 已经json格式显示统计信息                                                           |
| -I（大写i）                    | 统计中断信息                                                                   |

### 输出信息

| 选项     | 说明                       |
| ------ | ------------------------ |
| user   | 用户应用程序消耗的CPU时间百分比        |
| nice   | 修改过NI(优先级)的进程消耗的CPU时间百分比 |
| system | 系统消耗的CPU时间百分比            |
| IOwait | CPU花费的总IO等待时间百分比         |
| irq    | 处理中断消耗的CPU时间百分比          |
| soft   | 处理软中断消耗的CPU时间百分比         |
| idle   | CPU花费的总空闲时间百分比           |

## 6. sar(系统活动报告)

sar用另一种方法手机系统数据。sar能有效将收集到的系统性能数据记录到二进制文件，之后，可以重播这些文件。sar是一种低开销的、记录系统执行情况信息的方法。

sar命令可以记录性能信息，回放之前的记录信息，以及显示当前系统的实时信息。sar命令可以进行格式化，使之易于导入数据库，或是输送给其他linux命令进行处理。

```shell
sar [ options ] [ <interval> [ <count> ] ]
#eg
sar 1 3
```

### 参数

| 选项                    | 说明                                      |
| --------------------- | --------------------------------------- |
| -f filename           | 指定性能统计信息的文件名                            |
| -o filename           | 指定保存性能统计信息的二进制输出文件名                     |
| -H                    | 显示大页面使用信息                               |
| --human               | 使用更友好的格式展示                              |
| -P { cpu_list \|ALL } | 指定从哪个CPU收集信息，如果不指定则报告系统整体情况             |
| -q                    | 报告机器运行队列长度和平均负载                         |
| -u [ ALL ]            | 报告系统CPU使用情况，该项为默认输出                     |
| -w                    | 报告系统中已发生的上下文切换次数                        |
| interval [ count ]    | 刷新时间间隔和刷新次数                             |
| -B                    | 报告缺页数量                                  |
| -W                    | 报告系统交换的页数                               |
| -r                    | 报告系统使用的内存信息，包括总的空闲内存，正在使用的交换分区、缓存和缓冲区信息 |
| -d                    | 磁盘IO选项；显示磁盘使用情况的统计信息                    |

### 输出信息

**CPU相关信息**

| 选项       | 说明                           |
| -------- | ---------------------------- |
| user     | 用户应用程序消耗的CPU时间百分比            |
| nice     | 修改过NI(优先级)的进程消耗的CPU时间百分比     |
| system   | 系统消耗的CPU时间百分比                |
| IOwait   | CPU花费的总IO等待时间百分比             |
| idle     | CPU花费的总空闲时间百分比               |
| runq-sz  | 采样时，运行队列的长度                  |
| plist-sz | 采样时的进程（运行，睡眠或等待IO）数          |
| ldavg-1  | 前1分钟的平均负载                    |
| ldavg-5  | 前5分钟的平均负载                    |
| ldavg-15 | 前15分钟的平均负载                   |
| proc/s   | 每秒新建进程数（该项等同于vmstat中的forks项） |
| cswch    | 每秒上下文切换次数                    |
| intr/s   | 每秒触发的中断数                     |

**内存相关信息**

| 选项        | 说明                            |
| --------- | ----------------------------- |
| pgpgin/s  | 内核以换页形式每秒从磁盘换入的内存容量（以KB为单位）   |
| pgpgout/s | 内核以换页形式每秒换出到磁盘的内存容量（以KB为单位）   |
| fault/s   | 每秒内存子系统需满足的缺页总数。这些缺页不一定需要访问磁盘 |
| majflt/s  | 每秒内存子系统需满足的缺页总数。这些缺页需要访问磁盘    |
| pswpin/s  | 每秒系统装入内存的交换分区总量（按页计）          |
| pswpout/s | 每秒系统写入到交换分区的内存总量（按页计）         |
| kbmemfree | 当前空闲的物理内存总量                   |
| kbmemused | 当前被使用的物理内存总量                  |
| %memused  | 被使用的物理内存总量所占的百分比              |
| kbbuffers | 用作磁盘写缓存区的物理内存总量               |
| kbcached  | 用作磁盘读缓存的物理内存总量                |

**IO相关信息**

| 选项    | 说明                       |
| ----- | ------------------------ |
| tps   | 每秒传输数。该项为每秒对设备/分区进行读写的次数 |
| rkB/s | 每秒读取的数据KB数               |
| wkB/s | 每秒写入的数据KB数               |

## 7. free

free提供了系统使用内存的总体情况

```shell
free [options]
```

### 参数

| 选项          | 说明                     |
| ----------- | ---------------------- |
| -b/-k/-m/-g | 以B/K/M/G为单位显示          |
| -h          | 以更可读的方式显示              |
| -l          | 显示使用了多少高端内存和多少低端内存     |
| -s N        | 使free按每N秒的时间间隔输出内存统计数据 |
| -c N        | 总共显示N次内存数据             |

### 输出信息

| 选项         | 说明                                                            |
| ---------- | ------------------------------------------------------------- |
| Total      | 物理内存与交换空间的总量                                                  |
| Used       | 使用的物理内存与交换空间的总量                                               |
| Free       | 未使用的物理内存与交换空间的总量                                              |
| Shared     | 该项已过时，应忽略                                                     |
| buff/cache | buffers和cache的总和                                              |
| available  | 估计有多少内存可用于启动新应用程序，不包含交换区。 与 cache 或 free 字段提供的数据不同，该字段考虑了页面缓存 |
| Low        | 低端内存，或能被内核直接访问的内存总量                                           |
| High       | 高端内存，或不能被内核直接访问的内存总量                                          |
| Totals     | 对Total，Used和Free列，该项显示的是该列中物理内存和交换分区的总和                       |

## 8. opprofile

```shell
sudo apt install opprofile
```

OProfile 是用于动态程序分析的探查器。它可以调查运行中程序的行为并收集信息。可以查看这些信息，并从中获得用于进一步优化的提示。

无需重新编译或使用封装程序库即可使用 OProfile。甚至不需要内核补丁。通常，在探查应用程序时，预期会产生较小的开销，具体取决于工作负载和采样频率。

OProfile 由一个内核驱动程序以及一个用于收集数据的守护程序构成。它使用许多处理器上都会提供的硬件性能计数器。OProfile 能够探查所有代码，包括内核、内核模块、内核中断处理程序、系统共享库和其他应用程序。

OProfile 包含多个实用程序，用于处理探查进程及其探查到的数据。

**opannotate**

输出带批注的源代码或程序集列表（混合有探查信息）。可将带批注的报告与 `addr2line` 结合使用，以识别可能存在热点的源文件和行。有关详细信息，请参见 `man addr2line`。

**operf**

探查器工具。例如，在探查停止后，`opreport` 可以处理默认储存在 `*CUR_DIR*/oprofile_data/samples/current` 中的数据。

**ophelp**

列出可用事件和简短说明。

**opimport**

将样本数据库文件从外部二进制格式转换为本机格式。

**opreport**

基于探查到的数据生成报告。

## 9. strace

strace是当程序执行时，追踪其发起的系统调用的工具。**系统调用**是指应用程序调用linux内核函数，通过strace输出，可以了解应用程序如何使用内核，以及它依赖什么类型的函数。

应用程序运行后，strace会给出一个表格，显示每个系统调用的频率和该类型调用所花费的总时间。

strace报告的调用次数会比它报告的每个调用的时间更加可靠一些。应使用strace提供的次数作为调查的起点，而不是每个调用所花费的时间的高度精确的测量值。

```shell
strace [option] command
strace -c ll
```

### 参数

| 选项      | 说明                              |
| ------- | ------------------------------- |
| -c      | 使strace打印出统计信息的概要，而非所有系统调用的独立列表 |
| -p pid  | 将给定pid添加到进程，并开始跟踪               |
| -o file | strace的输出将保存到file               |
| --help  | 列出strace选项的完整汇总                 |

### 输出信息

| 选项         | 说明                               |
| ---------- | -------------------------------- |
| % time     | 对全部系统调用的总时间来说，该项为这一个系统调用所花时间的百分比 |
| seconds    | 这一个系统调用所花费的总秒数                   |
| usecs/call | 这个类型的一个系统调用所花费的微秒数               |
| calls      | 这个类型的所有系统调用的总数                   |
| errors     | 这个系统调用返回的错误的次数                   |
| syscall    | 系统调用名                            |

## 10. ltrace

ltrace与strace的概念相似，但它跟踪的是应用程序对库的调用而不是对内核的调用。虽然ltrace主要用于提供对库调用的参数和返回值得精确跟踪，但是你也可以用它来汇总每个调用所花的时间。这使得你既可以发现应用程序有哪些库调用，又可以发现每个调用时间是多长。

**注意**：如果一个库函数调用了另一个函数，则花费的时间要计算两次。比如：如果库函数foo()调用了函数bar()，则函数foo()的报告时间将是函数foo()运行时间加bar()运行时间。

```shell
ltrace [option ...] [command [arg ...]]
```

### 参数

| 选项      | 说明                                    |
| ------- | ------------------------------------- |
| -c      | 使ltrace打印出统计信息的概要，而非所有库调用的独立列表        |
| -S      | 除了库调用外，ltrace还跟踪系统调用，该项与strace提供的功能相同 |
| -p pid  | 将给定pid添加到进程，并开始跟踪                     |
| -o file | strace的输出将保存到file                     |
| --help  | 列出strace选项的完整汇总                       |

### 输出信息

| 选项         | 说明                             |
| ---------- | ------------------------------ |
| % time     | 对全部库调用的总时间来说，该项为这一个库调用所花时间的百分比 |
| seconds    | 这一个库调用所花费的总秒数                  |
| usecs/call | 这个类型的一个库调用所花费的微秒数              |
| calls      | 这个类型的所有库调用的总数                  |
| errors     | 这个系统调用返回的错误的次数                 |
| function   | 库调用名                           |

## 11. ps

ps是极好的跟踪运行进程的命令。它给出正在运行进程的详细信息的静态和动态信息。ps提供的静态信息包括命令名和PID，动态信息包括内存和CPU的使用情况。

```shell
ps [options] pid
#eg
ps -ef   #不会截断command
ps -aux  #会截断command
```

### 参数

| 选项                | 说明           |
| ----------------- | ------------ |
| -A, -e            | 显示所有进程       |
| -f                | 显示所有信息       |
| -u, U, --user UID | 显示用户id或名称    |
| x                 | 不控制 ttys 的进程 |

**内存相关参数**

```shell
ps -o sz,rss,tsiz,dsiz,majflt,minflt,pmem,cmd  2190
```

| 选项       | 说明                                                                                                                  |
| -------- | ------------------------------------------------------------------------------------------------------------------- |
| -o  统计信息 | 允许你指定想要跟踪的确定的进程统计信息。不同的统计数据由列表给出，列表项用逗号隔开，且中间没有空格                                                                   |
| vsz      | 统计数据：虚拟集大小是指应用程序使用的虚拟内存的容量。由于linux只在应用程序试图使用物理内存时才分配它，因此，该项数值可能会比应用程序使用的物理内存大很多                                     |
| rss      | 统计数据：驻留集大小是指应用程序当前使用的物理内存量                                                                                          |
| tsiz     | 统计数据：文本大小是指程序代码的虚拟大小。再强调一次，这不是实际大小，而是虚拟大小；但是该值清晰地表明了程序的大小                                                           |
| dsiz     | 统计数据：数据大小是指程序数据使用量的虚拟大小。该值清晰地表明了应用程序的数据结构和堆栈的大小                                                                     |
| majflt   | 统计数据：主故障是指使得linux进程从磁盘读取页面的缺页故障的数量。这种故障可能发生情况是：当进程访问的一块数据或指令仍留在磁盘上时，linux要为应用程序进行无缝加载                               |
| minflt   | 统计数据：次故障是指linux不用诉诸磁盘读取就可以解决的故障数量。如果应用程序涉及一块已经由linux内核分配的内存，就有可能发生这种情况。这种情况不需要访问磁盘，因为linux内核只需要选择一块空闲内存并将其分配给应用程序即可 |
| pmem     | 统计数据：进程消耗的内存百分比                                                                                                     |
| cmd      | 命令名                                                                                                                 |

## 12. gprof

gprof可以展示应用程序的调用图，并采样该应用程序的时间都花在哪里。

使用步骤：

1. 在编译和链接时 加上-pg -g3选项。一般我们可以加在 makefile 中。
2. 执行编译的二进制程序。执行参数和方式同以前。
3. 在程序运行目录下 生成 gmon.out 文件。如果原来有gmon.out 文件，将会被重写
4. 结束进程。这时 gmon.out 会再次被刷新。
5. 用 gprof 工具分析 gmon.out 文件。

```shell
gprof [option] bin
#eg
gprof --brief -p ./test
```

### 参数

| 选项      | 说明                                                        |
| ------- | --------------------------------------------------------- |
| --brief | 简化gprof的输出。默认情况下，gprof输出全部的性能信息，并用图例解释每个指标的含义，该选项删除了图例    |
| -p      | 显示应用程序中每个函数花费的总时间和其调用次数                                   |
| -q      | 打印出已剖析的应用程序的调用图。其显示了程序中的函数是如何相互调用的，每个函数所花费的时间，以及子函数所花费的时间 |
| -A      | 在原始代码的下面显示剖析信息                                            |

### 输出信息

| 选项                 | 说明                            |
| ------------------ | ----------------------------- |
| %time              | 该函数消耗时间占程序所有时间百分比             |
| Cumulative seconds | 程序的累积执行时间（只是包括gprof能够监控到的函数）  |
| Self  Seconds      | 该函数本身执行时间（所有被调用次数的合共时间）       |
| Calls              | 函数被调用次数                       |
| Self ms/call       | 函数平均执行时间（不包括被调用时间）（函数的单次执行时间） |
| Total ms/call      | 函数平均执行时间（包括被调用时间）（函数的单次执行时间）  |
| name               | 函数名                           |
| Index              | 索引值                           |
| Self               | 函数本身执行时间                      |
| Children           | 执行子函数所用时间                     |
| Called             | 被调用次数                         |

## 13. /proc/\<PID\>

/poc文件系提供的信息通常仅被如ps之类的性能工具用于内核提取性能数据。尽管一般不需要深入挖掘/proc中的文件，但是它确实能提供其他性能工具所无法检索到的一些信息

```shell
cat /proc/<pid>/status
```

| 选项     | 说明                                        |
| ------ | ----------------------------------------- |
| Vmsize | 进程虚拟内存大小，是应用程序使用的虚拟内存量                    |
| VmLck  | 被进程锁定的内存量。被锁定的内存不能交换到磁盘                   |
| VmRSS  | 驻留集大小或程序当前使用的物理内存量。                       |
| VmData | 数据大小或程序使用数据量的虚拟大小。与ps的dsiz统计数不同，该项不包含堆栈信息 |
| VmStk  | 进程的堆栈的大小                                  |
| VmExe  | 程序的可执行内存的虚拟大小。不包含进程使用的库                   |
| VmLib  | 进程使用的库的大小                                 |

```shell
cat /proc/<pid>/maps
```

| 选项         | 说明                                      |
| ---------- | --------------------------------------- |
| Address    | 进程中库映射的地址范围                             |
| Permission | 内存区域的权限，其中：r=读，w=写，x=执行，s=共享，p=私有(写时复制) |
| Offset     | 库/应用程序内存映射区域开始处的偏移量                     |
| Device     | 这个特殊文件所在的设备（主设备号和次设备号）                  |
| Inode      | 映射文件的节点号                                |
| Pathname   | 映射到进程的文件的路径                             |

## 14. memprof

memprof是一种图形化的内存使用情况剖析工具。它展示了程序在运行时时如何分配内存的。memprof显示了应用程序消耗内存的总量，以及哪些函数消耗了多少内存。应用程序运行时，memprof会动态更新这些信息

监控是，应用程序使用-g3编译选项

## 15. valgrind

官网：https://www.valgrind.org/

valgrind是一个强大的工具，使你能够调试棘手的内存管理错误。valgrind模拟当前的处理器，并在这个虚拟处理器上运行应用程序，同事跟踪内存的使用情况。它还能模拟高数缓存，并确定程序在哪里有指定和数据高速缓存的命中或缺失。

* Memcheck。这是valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。这也是本文将重点介绍的部分。

* Callgrind。它主要用来检查程序中函数调用过程中出现的问题。

* Cachegrind。它主要用来检查程序中缓存使用出现的问题。

* Helgrind。它主要用来检查多线程程序中出现的竞争问题。

* Massif。它主要用来检查程序中堆栈使用中出现的问题。

* Extension。可以利用core提供的功能，自己编写特定的内存调试工具

```shell
# 调试cache命令率
valgrind --skin=cachegrind application
# 把高速缓存使用情况映射回应用程序源代码
cg_annotate --pid [--auto=yes|no]
# 调试内存泄漏,–leak-check=full 指的是完全检查内存泄漏，–show-reachable=yes是显示内存泄漏的地点，–trace-children=yes是跟入子进程。
valgrind --tool=memcheck --leak-check=full --show-reachable=yes --trace-children=yes ./leak
```

## 16. kcachegrind

kcachegrind与valgrind密切合作，提供关于被剖析应用程序的高速缓存使用情况的详细信息。它在标准valgrind的基础上增加了两个新的功能。首先它为valgrind提供了一个界面，称为calltree，以捕捉特定应用程序的高速缓存和调用数的统计信息。其次它还提供了对高速缓存性能的图形化展示，以及新颖的数据试图。

## 17. ipcs

ipcs是一种系统级工具，可以展示进程之间通信内存的信息。进程可分配整个系统共享的内存、信号量以及有系统上运行的多个进程所共享的共享的内存队列。

ipcs可用于跟踪哪些程序分配并使用了大量的共享内存。

如果共享内存使用量占了系统重量的很大一部分，那么ipcs是一个很好的方法来准确得跟踪哪些创建和使用共享内存的程序。

```shell
ipcs [options]
```

### 参数

| 选项      | 说明                                    |
| ------- | ------------------------------------- |
| -t      | 显示共享内存创建时间，进程最后访问该内存的时间，以及进程最后与之分离的时间 |
| -u      | 提供了关于共享内存使用量以及它是否已被交换到磁盘还是仍留在内存的汇总信息  |
| --human | 以更加可读的形式显示汇总信息                        |
| -l      | 显示对共享使用情况的系统级限制                       |
| -p      | 显示创建和最后使用共享内存段的进程的pid                 |
| -c      | 显示作为共享内存段的创建者和拥有者的用户                  |
| -b      | 使用bytes显示共享内存大小                       |

### 输出信息

| 选项                 | 说明              |
| ------------------ | --------------- |
| segments allocated | 被分配的内存段或内存片的数量  |
| pages allocated    | 共享内存占用的页数       |
| pages resident     | 驻留在物理内存中的共享内存页数 |
| pages swapped      | 交换到磁盘的共享内存页数    |
| owner              | 共享内存拥有者         |
| perms              | 共享内存权限，如600     |
| bytes              | 共享内存大小          |
| nattch             | 有多少个进程访问了它      |
| cpid               | 创建共享内存的进程       |
| lpid               | 最后使用共享内存的进程     |

## 18. iostat

iostat与vmstat相似，但它是一个专门用于磁盘IO子系统统计信息的工具。iostat提供的信息细化到每个设备和每个分区从特定磁盘读写了多少个块。（iostat中块大小一般为512字节。）此外，iostat还可以提供大量的信息来显示磁盘是如何被利用的，以及linux花费了多长时间来等待将请求提交到磁盘。

```shell
iostat [option] [device] [interval [count]]
#eg
iostat /dev/sda 1 3
```

### 参数

| 选项       | 说明                                    |
| -------- | ------------------------------------- |
| -d       | 只显示磁盘IO的统计信息，而不是默认信息。默认信息中还包括了CPU使用情况 |
| -k       | 按KB显示统计数据，而不是按块显示                     |
| -x       | 显示扩展性能IO统计信息                          |
| device   | 若指定设备，则iostat只显示该设备的信息                |
| interval | 采样间隔时间                                |
| count    | 获取的样本总数                               |

### 输出信息

| 选项        | 说明                        |
| --------- | ------------------------- |
| tps       | 每秒传输次数。该项为每秒对设备/分区读写请求的次数 |
| kB_read/s | 每秒度取磁盘的速率                 |
| kB_wrtn/s | 每秒写入磁盘的速率                 |
| kB_read   | 在时间间隔内读取块的总数量             |
| kB_wrtn   | 在时间间隔内写入块的总数量             |
| rrqm/s    | 在提交给磁盘前，被合并的读请求的数量        |
| wrqm/s    | 在提交给磁盘前，被合并的写请求的数量        |
| r/s       | 每秒提交给磁盘的读请求数量             |
| w/s       | 每秒提交给磁盘的写请求数量             |
| rkB/s     | 每秒从磁盘读取了多少KB数据            |
| wkB/s     | 每秒向磁盘写入了多少KB数据            |
| svctm     | 提交到磁盘的请求的平均服务时间（按毫秒计）     |

## 19. lsof

lsof提供了一种方法来确定哪些进程打开了一个特定的文件。除了跟踪单个文件的用户外，lsof还可以显示使用了特定目录下文件的进程。同时还可以递归搜索整个目录树，并列出使用了该目录树内文件的进程。在要筛选哪些应用程序产生了IO时，lsof是很有用的

```shell
lsof [-r delay] [+D directory] [-d directory] [file]
#eg
lsof -r 2 +D /usr/bin
```

### 参数

| 选项           | 说明                                 |
| ------------ | ---------------------------------- |
| -r delay     | 使得lsof每隔delay 秒输出一次统计数据            |
| +D directory | 使得lsof递归搜索给定目录下的所有文件，并报告哪些进程正在使用它们 |
| -d directory | 使得lsof报告哪些进程正在使用给定目录下的文件           |

### 输出信息

| 选项       | 说明                             |
| -------- | ------------------------------ |
| COMMAND  | 打开该文件的命令的名称                    |
| PID      | 打开该文件的命令的PID                   |
| USER     | 打开文件的用户                        |
| FD       | 该文件的描述符。txt表示可执行文件，mem表示内存映射文件 |
| TYPE     | 文件类型，REG表示常规文件                 |
| DEVICE   | 用主设备号和次设备号表示的设备编号              |
| SIZE/OFF | 文件的大小                          |
| NODE     | 文件的索引节点                        |
| NAME     | 文件名                            |

## 20. iotop

iotop是进程级别IO监控

```shell
iotop [command]
# eg
sudo iotop -n 1 -b -o
```

### 参数

| 选项      | 说明                                                                                |
| ------- | --------------------------------------------------------------------------------- |
| -o      | 只显示正在产生I/O的进程或线程，运行过程中，可以通过按o随时切换                                                 |
| -b      | 非交互模式下运行，一般用来记录日志。                                                                |
| -n NUM  | 设置监控（显示）NUM次，主要用于非交互模式。默认无限                                                       |
| -d SEC  | 设置显示的间隔秒数，支持非整数                                                                   |
| -p PID  | 只显示指定进程（PID）的信息                                                                   |
| -u USER | 显示指定的用户的进程的信息                                                                     |
| -P      | 只显示进程，不显示所有线程                                                                     |
| -a      | 累积的I/O,显示从iotop启动后每个进程累积的I/O总数，便于诊断问题                                             |
| -k      | 显示使用KB单位                                                                          |
| -t      | 非交互模式下，加上时间戳。                                                                     |
| -q      | 只在第一次监测时显示列名. 去除头部一些行：这个参数可以设置最多3次来移除头部行：-q列头部只在最初交互显示一次；-qq列头部不显示；-qqq，I/O的总结不显示 |

### 运行时选项

| 选项  | 说明        |
| --- | --------- |
| r   | 反向排序      |
| o   | -o的运行时切换  |
| p   | 进程、线程之间切换 |
| a   | 退出-a模式    |
| q   | 退出        |
| i   | 改变线程的优先级  |

### 输出信息

| 选项         | 说明                                                                                     |
| ---------- | -------------------------------------------------------------------------------------- |
| TID        | 进程PID                                                                                  |
| PRIO       | PRIO is the I/O priority at which the thread is running (set using the ionice command) |
| USER       | 用户名                                                                                    |
| DISK READ  | 读磁盘速率                                                                                  |
| DISK WRITE | 写磁盘速率                                                                                  |
| SWAPIN     | 每个进程的交换区使用率                                                                            |
| IO         | 每个进程的 I/O 利用率，包含磁盘和交换。                                                                 |
| COMMAND    | 进程名                                                                                    |

## 21. objdump

objdump可以用来确定给定的库提供了哪些函数。

```shell
# 显示libgtk库中所有函数
objdump -T /usr/lib/libgtk.so | fgrep .text
```

-T选项，显示该库/二进制所依赖或提供的全部符号。这些符号可以是数据结构，也可以是函数。包含.text的每一行objdump输出都是该二进制文件提供的一个函数。

## 22. oprofile

```shell
operf [ options ] [ --system-wide | --pid=<PID> | [ command [ args ] ] ]
#eg
operf ./my_test_program my_arg
#当./my_test_program完成时（或按Ctrl-C），剖析停止，你就可以使用opreport或其他OProfile的后处理工具。默认情况下，operf将示例数据存储在 中<cur_dir>/oprofile_data/samples/current，并且opreport和其他后处理工具将首先在该位置查找配置文件数据，除非您传递该--session-dir选项。
```

# 优化CPU使用情况

1. 使用time命令来确定一个应用程序在内核和用户模式下消耗的时间。opprofile也可以用来确定时间花在哪里。
2. 如果应用程序在内核空间消耗了大量的时间（超过25%），使用strace查看有哪些系统调用，以及他们完成的时长是多少，减少系统调用次数有可能提升性能
3. 如果应用程序在用户空间消耗时间比较多，使用oprofile确定热点函数（哪些函数耗时较多）
4. 这些函数调用次数是否可以减少，使用gprof，oprofile，ltrace
5. 这些代码行为热点是应为cache缺失吗，使用profile，cachegrind，kcache

# 优化内存使用情况

一般使用大量内存的应用程序通常会导致其他一些性能问题的产生，比如cache缺失，转换后援缓冲器（TLB）缺失以及交换

1. 内核使用的内存量在增加吗？使用slabtop查看内核的内存总量大小是否增加
2. 内核使用的内存类型是什么？如果内核使用的内存量在增加，再次使用slabtop来确定内核分配的内存类型
3. 特定进程的驻留集大小在增加吗？使用top或ps查看特定进程的驻留集大小是否在增加（rss字段）
4. 如果在增加，那么进程使用的内存类型是什么？ 使用/proc/pid/status查看进程内存使用的信息
5. 共享内存的使用量增加了吗？使用ipcs来确定被使用的共享内存的数量是否在增加
6. 哪些进程使用了共享内存，使用ipcs来确定哪些进程使用并分配了共享内存
7. 哪些函数正在使用全部的栈？使用gdb 的bt回溯，使用info registers esp输出栈指针，通过栈指针差值确定函数使用的栈的容量
8. 哪些函数的文本大小最大？使用nm -S -size -sort了解每个函数的大小
9. 进程使用的库多大？使用/proc/pid/map显示每个库及其代码与数据的大小
10. 哪些函数分配堆内存？使用memprof找出哪些函数分配了堆内存

# 优化磁盘IO使用

1. 系统强调特定磁盘吗？使用iostat寻找await大于零的分区
2. 哪个应用程序访问了磁盘？
3. 应用程序访问了哪些文件？通过strace -e trace=file来追踪应用程序中所有与文件IO相关的系统调用

# 优化网络IO使用

1. 网络设备发送/接收量接近理论极限了吗？使用ethtool确定网络设备的硬件速度是多少；使用iptraf来明确流经每个接口的流量
2. 网络设备产生了大量错误吗？使用ifconfig来确定是否有接口产生了大量的错误
3. 设备上流量的类型是什么？使用iptraf可以跟踪该设备发送和接收的流量类型
4. 特定进程要为流量负责吗？使用netstat -p查看是否有进程在处理流经网络端口的类型流量
5. 流量是那个远程系统发送的？使用iptraf或etherape
6. 哪个应用程序套接字要为流量负责？使用strace -e trace=file跟踪应用程序所有IO系统调用。通过查看/proc/pid/fd/中的文件是从文件描述符到实际文件或套接字的符号链接

## 参考

https://blog.csdn.net/u010317005/article/details/80531985

oprofile文档：https://oprofile.sourceforge.io/docs/
