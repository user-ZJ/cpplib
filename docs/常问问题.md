# C++常问问题

### 1. 介绍一下C++

C++ 是一门偏向系统编程的通用编程语言，它是：

* 更好的 C

* 支持数据抽象

* 支持面向对象编程

* 支持泛型编程

### 1. C++是不是类型安全的

不是。两个不同类型的指针之间可以强制转换（用reinterpret_cast)

### 2. main 函数执行以前，还会执行什么代码

main函数执行之前，主要就是初始化系统相关资源：

1.设置栈指针

2.初始化static静态和global全局变量，即data段的内容

3.将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL，等等，即.bss段的内容

4.运行全局构造器，构造全局对象，全局对象的析构函数在main之后被执行。

5.将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数

### 3. 描述内存分配方式以及它们的区别

C++程序内存由栈区、堆区、数据区（静态存储区）、程序代码区和常量区组成

1. 从静态存储区域分配。内存在程序**编译的时候**就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。
   
   初始化的全局变量和静态变量在一块区域(.data)，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域(.bss)

2. 在栈上创建。在执行函数时，函数内局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元自动被释放。局部通过构造函数创建的对象也在栈上

3. 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。

4. 代码区：存放CPU执行的机器指令，代码区是可共享，并且是只读的

5. 常量区：存放常量的区间，如字符串常量等，注意在常量区存放的数据一旦经初始化后就不能被修改。 程序结束后由系统释放

```cpp
int a = 0;          // 全局初始化区 
char *p1;         // 全局未初始化区
char s1[] = "abcdef"; //1） s1在静态区，"abcdef"无需额外存放，就是数组s1内部，总共占用一个串的内存
const char *p ="abcdef";//2）p在静态区,"abcdef",必须额外存放（在常量区，通常也在静态区），/总共占用一个指针，和一个串的内存

void main() 
{ 
  int b;            // 栈区
  char s[]="abcdef";//s是在栈区，“abcdef”在常量区，运行的时候复制给s，
  *s='w';//正确
  s[2]='w';//正确
  const char *p3 = "123456"; // p3在栈区，"123456"在常量区,其值不能被修改，指向常量的指针是不可以通过指针移动去修改指针所指内容的
  *p3='w';//错误,此区域是编译的时候确定的，并且程序结束的时候自动释放的， *p3= 'w';企图修改文字常量区引起错误
  char *p2;         // 栈区
  static int c =0;         // 全局（静态）初始化区 
  p1 = (char *)malloc(10); 
  p2 = (char *)malloc(20); // 分配得来的10和20字节的区域就在堆区 
  strcpy(p1, "123456");    // "123456" 放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方 
} 
```

### 4. new 与malloc有什么区别

1. **属性**：new和delete是C++关键字，需要编译器支持；malloc和free是库函数，需要头文件支持。

2. **参数**：使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。

3. **返回类型**：new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型

4. new/delete 主要是用在类对象的申请和释放。申请的时候会调用构造器完成初始化，释放的时候，会调用析构器完成内存清理。

5. **内存区域**：new和malloc申请的内存都在堆中，只有静态建立，如A a的对象在栈中

6. **分配失败**：new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL

7. **对数组的处理**：new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会造成数组对象部分释放的现象，造成内存泄漏。malloc，所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小。
   
   int* arr = new int[n];//创建一维数组      delete[] arr;//销毁

8. **是否可以被重载**：opeartor new /operator delete可以被重载。malloc/free并不允许重载

9. **new与malloc是否可以相互调用**：operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。

### 5. 全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？

全局变量随主程序创建而创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；

使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。 

**操作系统和编译器通过内存分配的位置来知道的**，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 

### 6. 什么是内存泄漏？什么是野指针、空悬指针？什么是内存越界？如何避免？

**内存泄漏**：

1. 用动态内存分配函数动态开辟的空间，在使用完毕后未释放，程序结束后，会导致一直占据该内存单元，直到程序结束
2. 没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露。
3. 使用varglind和mtrace检测内存泄露

**空悬指针：**指向已经销毁的对象或已经回收的地址

**野指针**：未经初始化的指针

产生的原因：
 1）指针变量没有初始化。因此，创建指针变量时，该变量要被置为NULL或者指向合法的内存单元。
 2）指针p被free之后，没有置为NULL，让人误以为p是个合法的指针。
 3）指针跨越合法范围操作。不要返回指向栈内存(非静态局部变量）的指针或引用。
 可能后果：

- 若操作系统将这部分已经释放的内存重新分配给另外一个进程，而原来的程序重新引用现在的迷途指针，向其中写入数据，则这部分程序内容将被破坏，而导致程序错误。这种类型的程序错误，通常会导致segment fault和一般的保护错误。
- 其他常见错误：返回一个基于栈分配的局部变量的地址时，一旦调用的函数返回，分配给这些变量的空间将回收，此时它们拥有的是垃圾值，如return &num，如果要使它的生命周期边长，应该将其声明为static

**内存越界**：内存访问越界，简单的说，你向系统申请了一块内存，在使用这块内存的时候，超出了你申请的范围。

存在一种情况就是调用栈溢出(stackoverflow)，还有一种情况是缓冲区溢出，这两种情况都会导致安全漏洞。

1. 缓冲区溢出：strcpy会一直复制直到碰到\0，很多平台的栈变量是按照地址顺序倒着分配的（高地址向低地址），所以destination溢出后会先修改先前定义的变量，这样黑客就可以把is_administrator改为true，从而造成缓冲区溢出攻击,当然数组越界也可以造成类似的效果，不过现在C++都提供了越界检查的版本
2. 栈溢出攻击：在栈上分配length字节的空间，再往栈顶放上一个data。当Length十分大，会把data挤到栈空间之外，此时如果编译器不做越界检查的话，那么黑客只要用客户端送特定的length和data，就能改写服务器的任意内存(比如黑客可以修改服务器代码的机器码，注入一些JMP指令跳转到黑客想执行的函数)

### 6. C++可能出现的内存问题

1. 缓存区溢出。
   使用vector/string或自己编写buffer class来管理缓冲区，自动记住缓冲区的长度，并通过成员函数而不是裸指针来修改缓冲区
2. 空悬指针，野指针
   使用shared_ptr weak_ptr
3. 重复释放
   使用智能指针
4. 内存泄漏
   使用智能指针
5. 不配对的new/delete
   使用std::vector 或指针指针
6. 内存碎片

### 7. static全局变量与普通的全局变量有什么区别？

全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于作用域的扩展上。**非静态的全局变量可以用extern扩展到组成源程序的多个文件中，而静态的全局变量的作用域只限于本文件，不能扩展到其它文件**，由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。把全局变量改变为静态全局变量后是改变了它的作用域，限制了它的使用范围。

### 8. static关键字

static作用是控制作用范围和数据存放在静态区

1. **函数体内 static 变量**的作用范围为该函数体，不同于 auto 变量， 该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值
2. 在**模块内的 static 全局变量**可以被模块内所有函数访问，但不能被模块外其他函数访问
3. **static函数**与普通函数作用域不同,仅在本文件。在模块内的static 函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内
4. static函数与普通函数最主要区别是static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。
5. 在**类的static 成员变量**属于整个类所拥有，对类的所以对象只有一份拷贝。静态数据成员不能在类中初始化，一般在类外和main()函数之前初始化
6. **静态成员函数**与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。

### 9. 请说出const与#define 相比，有何优点

const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。

修饰函数返回值时可以阻止用户修改返回值。返回值也要相应的赋给一个常量或常指针

1. #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用
2. #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。
3. \#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份
4. const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了
5. const声明时需要定义（即赋初值）

### 12. const成员变量和成员函数

**const成员变量**：

const成员变量都要放在初始化列表之中进行

**const成员函数：**

1. 有 const 修饰的**成员函数**（指 const 放在函数参数表的后面，而不是在函数前面或者参数表内），只能读取数据成员，不能改变数据成员；
2. const成员函数只能调用const成员函数，不能调用非const成员函数；另一种说法：非const成员函数只可以访问非const对象的任意的数据成员（不能访问const对象的任意数据成员）
3. 需要强调的是，必须在成员函数的声明和定义处同时加上 const 关键字
4. 值得注意的是，把一个成员函数声明为const可以保证这个成员函数不修改数据成员，但是，如果据成员是指针，则const成员函数并不能保证不修改指针指向的对象，编译器不会把这种修改检测为错误。
5. **const对象**只能调用const成员函数,必须要提供一个const版本的成员函数
6. 如果只有const成员函数，**非const对象**是可以调用const成员函数的。当const版本和非const版本的成员函数同时出现时，非const对象调用非const成员函数。

### 10. final

1. final修饰类，表示类不能被继承
2. final修饰类中方法，表示方法不能被overide

### 10. extern

1. extern “C”告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的。C++语言在编译的时候为了解决函数的**重载**，会将函数名和参数类型联合起来生成一个中间的函数名称，而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。
   
   C++函数签名包含了一个函数的信息，包括函数名、它的参数类型、它所在的类和名称空间及其他信息。函数签名用于识别不同的函
   数，就像签名用于识别不同的人一样，函数的名字只是函数签名的一部分。

2. 修饰变量或函数时，它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块或其他模块中使用；记住它是一个**声明不是定义**
   
   也就是说B模块要是引用模块A中**定义**的全局变量或函数时，它只要包含A模块的头文件（头文件中用extern申明）即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。
   
   **一般只在文件中做声明**
   
   ```cpp
   //test1.h
   #ifndef TEST1H
   #define TEST1H
   extern char g_str[]; // 声明全局变量g_str
   void fun1();
   #endif
   //test1.cpp
   #include "test1.h"
   char g_str[] = "123456"; // 定义全局变量g_str
   void fun1() { cout << g_str << endl; }
   //test2.cpp
   #include "test1.h"
   void fun2()    { cout << g_str << endl;    }
   ```

### 11. extern 和 static

extern 表明该变量在别的地方已经定义过了,在这里要使用那个变量.

static 表示静态的变量，分配内存的时候, 存储在静态区,不存储在栈上面.

extern和static不能同时修饰一个变量

static修饰的全局变量声明与定义同时进行，也就是说当你在头文件中使用static声明了全局变量后，它也同时被定义了；

static修饰全局变量的作用域只能是本身的编译单元，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它

**一般定义static全局变量时，都把它放在原文件中而不是头文件**，这样就不会给其他模块造成不必要的信息污染

### 12. extern 和const

const有两个语义：只读和常量

```cpp
const int a = 5;  //常量
int b = 6;
const int &c = b;  //只读
b = 10;
```

当与extern连用来声明该常量可以作用于其他编译模块中, 如extern const char g_str[];

const修饰的全局常量只能作用于本编译模块中，因为常量不可变，所以声明和定义需要一起

### 13. register存储类型

register：这个关键字请求编译器尽可能的将变量存在CPU内部**`寄存器`**中，而不是通过内存寻址访问，因此访问register变量将在很大程度上提高效率，因为省去了变量由内存调入到寄存器过程中的好几个指令周期。**注意是尽可能，不是绝对**

register修饰符的注意点：

1. register变量必须是能被CPU所接受的类型。这通常意味着register变量必须是一个单个的值，并且长度应该小于或者等于整型的长度。不过，有些机器的寄存器也能存放浮点数。 
2. 因为register变量可能不存放在内存中，所以不能用“&”来获取register变量的地址。 
3. 由于寄存器的数量有限，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。 
4. 在某些情况下，把变量保存在寄存器中反而会降低程序的运行速度。因为被占用的寄存器不能再用于其它目的；或者变量被使用的次数不够多，不足以装入和存储变量所带来的额外开销。 
5. 随着编译程序设计技术的进步，在决定那些变量应该被存到寄存器中时，现在的C编译环境能比程序员做出更好的决定。实际上，许多编译程序都会忽略register修饰符，因为尽管它完全合法，**`但它仅仅是暗示而不是命令`**。

### 14. explicit

C++中， 一个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色。 

1 是个构造；2 是默认且隐含的类型转换操作符。

```cpp
#include <iostream>
using namespace std;
class Test1
{
  public :
    Test1(int num):n(num){}
  private:
    int n;
};
class Test2
{
  public :
    explicit Test2(int num):n(num){}
  private:
    int n;
}; 
int main()
{
    Test1 t1 = 12;  //调用构造函数
    Test2 t2(13);
    Test2 t3 = 14;    //报错
    return 0;
}
```

**explicit的作用是用来声明类构造函数是显示调用的**，而非隐式调用，所以只用于修饰单参构造函数。因为无参构造函数和多参构造函数本身就是显示调用的。

当类的声明和定义分别在两个文件中时，explicit只能写在在声明中，不能写在定义中。

### 15. volatile

volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改；遇到这个关键字声明的变量，**编译器对访问该变量的代码就不再进行优化**，从而可以提供对特殊地址的稳定访问。

```cpp
#include <stdio.h>

void main()
{
    volatile int i = 10;
    int a = i;

    printf("i = %d", a);
    __asm {
        mov dword ptr [ebp-4], 20h
    }

    int b = i;
    printf("i = %d", b);
}
```

一般说来，volatile用在如下的几个地方：

1. 中断服务程序中修改的供其它程序检测的变量需要加 volatile；
2. 多任务环境下各任务间共享的标志应该加 volatile；
3. 存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义；

在**多线程**中，有些变量是用 volatile 关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用 volatile 声明，该关键字的作用是**防止优化编译器把变量从内存装入 CPU 寄存器中**。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile 的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值

### 16. 指针

```cpp
char *const pc; //常指针(不可以修改p的值)
char const *pc1; //指向常量的指针(p所指向的内容不可修改)
const char *pc1;  //指向常量的指针
const int* const pc;  //指向常量的常指针
int (*p)[4];  //数组指针，指向一个大小为4个整型的数组的数组指针
    //数组名是地址，与数组首元素地址仅代表自己类型那么大内存不同，数组名内存指向能力非常强。
    //数组名指向整个数组空间。进一步讲，对数组名取地址，即就是在对整个数组取地址，则数组的地址自然要用指向数组的指针才能接收，
    //所以，必须定义指向数组的指针类型，即为数组指针。
    int ar[10] = { 1,2,3,4,5,6,7,8,9,10 };
    int **p = &ar;  //报错
    int(*pp)[10] = &ar; //正确
int *p[10];   //指针数组
int(*pfun)(int, int);  //函数指针，一般指针都有加1的能力，但是，函数指针不允许做这样的运算。即pfun+1是一个非法的操作
int* fun(int a, int b){} //指针函数，返回指针类型的函数称为指针函数，只要返回值为指针，无论是什么类型的指针，都称为指针函数
//返回函数指针的指针函数
int(*func(int a, int b, int(*FUN)(int, int))) (int, int){}
```

### 17. 简述数组与指针的区别

1. 数组是一块连续的内存，数组名指向内存地址。指针存放的是内存地址。

2. 同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝

3. 数组可以用sizeof求出数组占用内存大小，指针不行

### 18. 引用与指针有什么区别

**指针和引用都是地址的概念，指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。**

1. 引用必须被初始化，指针不必。
2. 引用初始化以后不能被改变，指针可以改变所指的对象。
3. 不存在指向空值的引用，但是存在指向空值的指针。
4. 对引用使用“sizeof”得到的是变量的大小，对指针使用“sizeof”得到的是变量的地址的大小。
5. 理论上指针的级数没有限制，但引用只有一级。即不存在引用的引用，但可以有指针的指针。
6. 就++操作而言，对引用的操作直接反应到所指向的对象，而不是改变指向；而对指针的操作，会使指针指向下一个对象，而不是改变所指对象的内容

### 19. 多态，虚函数，纯虚函数，抽象类

**多态**：是对于不同对象接收相同消息时产生不同的动作。

C++的多态性具体体现在运行和编译两个方面：在程序运行时的多态性通过继承和虚函数来体现；在程序编译时多态性体现在函数和运算符的重载上；

**虚函数**：在基类中冠以关键字 virtual 的成员函数。子类可以（也可以不）重新定义基类的虚函数，该行为称之为重写Override。

子类如果不提供虚函数的实现，将会自动调用基类的缺省虚函数实现，作为备选方案；

虚函数实现的过程是：**通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用。**所以虚函数的调用时由指针所指向内存块的具体类型决定的。

当基类中的某个成员方法，在大多数情形下都应该由子类提供个性化实现，但基类也可以提供缺省备选方案的时候，该方法应该设计为虚函数。

**纯虚函数**：在虚函数后加“=0”，如 virtual void func()=0；如果一个类中至少有一个纯虚函数，那么这个类被称为**抽象类**（abstract class）

从基类继承来的纯虚函数，在子类中仍是纯虚函数。子类如果不实现纯虚函数，而只是继承基类的纯虚函数，则子类也是抽象类

子类如果实现了所有的纯虚函数，则子类非抽象类，可以用来创建对象；实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数。

作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在 纯虚函数不具备函数的功能，一般不能直接被调用。

当基类中的某个成员方法，必须由子类提供个性化实现的时候，应该设计为纯虚函数。

**抽象类**：带有纯虚函数的类为抽象类，抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为**接口**的操作。用户不能创建类的实例。但仍可使用指向抽象类的指针支持运行时多态性。

抽象类中不仅包括纯虚函数，也可包括虚函数

### 20. 多态的实现

存在虚函数的类至少有一个(多继承会有多个)一维的虚函数表叫做虚表(virtual table)，属于类成员，虚表的元素值是虚函数的入口地址，在编译时就已经为其在数据端分配了空间。编译器另外还为每个类的对象提供一个虚表指针(vptr)，指向虚表入口地址，属于对象成员。在实例化派生类对象时，先实例化基类，将基类的虚表入口地址赋值给基类的虚表指针，当基类构造函数执行完时，再将派生类的虚表入口地址赋值给基类的虚表指针（派生类和基类此时共享一个虚表指针，并没有各自都生成一个），再执行子类的构造函数。
 以上是C++多态的实现过程，可以得出结论：

1. 有虚函数的类必存在一个虚表。
2. 虚表的构建：基类的虚表构建，先填上虚析构函数的入口地址，之后所有虚函数的入口地址按在类中声明顺序填入虚表；派生类的虚表构建，先将基类的虚表内容复制到派生类虚表中，如果派生类覆盖了基类的虚函数，则虚表中对应的虚函数入口地址也会被覆盖，为了后面寻址的一致性。

```cpp
class Person{ 
     . . . 
 public : 
    Person (){} 
    virtual ~Person (){}; 
    virtual void speak (){}; 
    virtual void eat (){}; 
 }; 

class Girl : public Person{ 
     . . . 
   public : 
   Girl(){} 
   virtual ~Girl(){}; 
   virtual void speak(){}; 
   virtual void sing(){}; 
```

![](images/duotai.png)

虚函数表中有序放置了父类和子类中的所有虚函数，并且相同虚函数在类继承链中的每一个虚函数表中的偏移量都是一致的。所以确定的虚函数对应virtual table中一个固定位置n，n是一个在编译时期就确定的常量，所以，使用vptr加上对应的n，就可以得到对应的函数入口地址。C++采用的这种绝对地址+偏移量的方法调用虚函数，查找速度快执行效率高，时间复杂度为O(1)
 这里概括一下虚函数的寻址过程：

1. 获取类型名和函数名
2. 从符号表中获得当前虚函数的偏移量
3. 利用偏移量得到虚函数的访问地址，并调用虚函数。

### 21. 重载（overload)和重写(overried）的区别

**重载**：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。

**重写**：是指子类重新定义父类虚函数的方法。和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定/动态绑定）

### 22. 子类析构时要调用父类的析构函数吗

定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；

析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。

### 23. 构造函数和析构函数可以是虚函数吗？

构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。

首先，我们已经知道虚函数的实现则是通过对象内存中的vptr来实现的。而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。那么在构造函数完成之前，也即还没有进行初始化，此时vptr是没有值的，也就无法通过vptr找到作为构造函数和虚函数所在的代码区，所以构造函数只能以普通函数的形式存放在类所指定的代码区中。

而对于析构函数，当我们delete(a)的时候，如果析构函数不是虚函数，那么调用的将会是基类base的析构函数。而当继承的时候，通常派生类会在基类的基础上定义自己的成员，此时我们当然希望可以调用派生类的析构函数对新定义的成员也进行析构。

### 24. C++构造函数是否可以抛出异常

构造函数可以抛出异常。但从逻辑上和风险控制上，构造函数中尽量不要抛出异常，既需要分配内存，又需要抛出异常时要特别注意防止内存泄露的情况发生。因为在构造函数中抛出异常，在概念上将被视为该对象没有被成功构造，因此当前对象的析构函数就不会被调用，就会造成内存泄漏。同时，由于构造函数本身也是一个函数，在函数体内抛出异常将导致当前函数运行结束，并释放已经构造的成员对象，包括其基类的成员，即执行直接基类和成员对象的析构函数

### 25. 是否在析构函数抛出异常

1) 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。
   
   2) 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。

2) 那么当无法保证在析构函数中不发生异常时， 其实还是有很好办法来解决的。那就是把异常完全封装在析构函数内部，决不让异常抛出函数之外。这是一种非常简单，也非常有效的方法。

### 26. 构造函数和析构函数可以调用虚函数吗

虽然可以对虚函数进行实调用，但程序员编写虚函数的本意应该是实现动态联编。在构造函数中调用虚函数，函数的入口地址是在编译时静态确定的，并未实现虚调用。但是为什么在构造函数中调用虚函数，实际上没有发生动态联编呢？
 第一个原因，在概念上，构造函数的工作是为对象进行初始化。在构造函数完成之前，被构造的对象被认为“未完全生成”。当创建某个派生类的对象时，如果在它的基类的构造函数中调用虚函数，那么此时派生类的构造函数并未执行，所调用的函数可能操作还没有被初始化的成员，将导致灾难的发生。
 第二个原因，即使想在构造函数中实现动态联编，在实现上也会遇到困难。这涉及到对象虚指针（vptr）的建立问题。在Visual C++中，包含虚函数的类对象的虚指针被安排在对象的起始地址处，并且**虚函数表（vtable）的地址是由构造函数写入虚指针**的。所以，一个类的构造函数在执行时，并不能保证该函数所能访问到的虚指针就是当前被构造对象最后所拥有的虚指针，因为后面派生类的构造函数会对当前被构造对象的虚指针进行重写，因此无法完成动态联编

### 27. 内联函数有什么优点？内联函数和宏定义的区别。

在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数。

**注意，要在函数定义处添加 inline 关键字，在函数声明处添加 inline 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字。**

当函数比较复杂时，函数调用的时空开销可以忽略，大部分的 CPU 时间都会花费在执行函数体代码上，所以我们一般是将非常短小的函数声明为内联函数。

使用内联函数的缺点也是非常明显的，编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大，所以再次强调，一般只将那些短小的、频繁调用的函数声明为内联函数。

内联函数和宏定义区别：

1. 内联函数在运行时**可调试**，而宏定义不可以;
2. 编译器会对内联函数的**参数类型做安全检查**或自动类型转换（同普通函数），而宏定义则不会；
3. 内联函数可以访问类的成员变量，宏定义则不能；
4. 在类中声明同时定义的成员函数，自动转化为内联函数
    内联函数和普通函数相比可以加快程序运行的速度，因为不需要中断调用，在编译的时候内联函数可以直接被镶嵌到目标代码中。
    内联函数要做参数类型检查，这是内联函数跟宏相比的优势。

### 28. 常见的STL容器有哪些？算法用过哪几个？

STL（Standard Template Library），即**标准模板库**，是一个高效的C++程序库，包含了诸多**常用的基本数据结构和基本算法**

顺序容器有以下三种：可变长动态数组 vector、双端队列 deque、双向链表 list，单向链表forward_list；此外也可以把 string 和 array 当做一种序列式容器。元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置（尾部、头部或中间某处）插入，元素就会位于什么位置

关联容器有以下四种：set、multiset(允许重复元素)、map、multimap(允许重复元素)，tuple。关联容器内的元素是排序的。插入元素时，容器会按一定的排序规则将元素放到适当的位置上，因此插入元素时不能指定位置。默认情况下，关联容器中的元素是从小到大排序（或按关键字从小到大排序）的，而且用`<`运算符比较元素或关键字大小。因为是排好序的，所以关联容器在查找时具有非常好的性能。

除了以上两类容器外，STL 还在两类容器的基础上屏蔽一部分功能，突出或增加另一部分功能，实现了三种容器适配器：栈 stack、队列 queue、优先级队列 priority_queue。

容器都是类模板。它们实例化后就成为容器类。用容器类定义的对象称为容器对象。

容器中可以存放基本类型的变量，也可以存放对象。对象或基本类型的变量被插入容器中时，实际插入的是对象或变量的一个复制品。

STL 中的许多算法（即函数模板），如排序、查找等算法，在执行过程中会对容器中的元素进行比较。这些算法在比较元素是否相等时通常用运算符进行，比较大小通常用`<`运算符进行，因此，被放入容器的对象所属的类最好重载`==`和`<`运算符，以使得两个对象用`==`和`<`进行比较是有定义的。‘

- int size()：返回容器对象中元素的个数。
- bool empty()：判断容器对象是否为空。
- begin()：返回指向容器中第一个元素的迭代器。
- end()：返回指向容器中最后一个元素后面的位置的迭代器。
- rbegin()：返回指向容器中最后一个元素的反向迭代器。
- rend()：返回指向容器中第一个元素前面的位置的反向迭代器。
- erase(...)：从容器中删除一个或几个元素。该函数参数较复杂，此处省略。
- clear()：从容器中删除所有元素。
- front()：返回容器中第一个元素的引用。
- back()：返回容器中最后一个元素的引用。
- push_back()：在容器末尾增加新元素。
- pop_back()：删除容器末尾的元素。
- insert(...)：插入一个或多个元素。该函数参数较复杂，此处省略。

**算法**:查找，查找重复值，排序

https://zhuanlan.zhihu.com/p/158647883

### 29. 线程和进程的联系和区别

每个进程都有自己独立的一块内存空间，一个进程可以有多个线程。

一台机器上的多个进程能高效的共享**代码段**(操作系统可以映射为同样的物理内存)，但不能共享数据。多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程

通常一个进程都有若干个线程，至少包含一个线程。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。

**根本区别**：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位

**资源开销**：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

**包含关系**：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程

**内存分配**：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的

**影响关系**：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

**执行过程**：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行

### 30. 进程间的通信方式(IPC inter-process communication)

进程间通信可以分为两种方式：

1. 共享内存  (共享内存，内存映射)
2. 消息传递  （管道，命名管道，消息队列，信号，信号量，socket）

通过链接方式传递消息：

a. 如何建立链接 b. 链接是否可以关联两个以上进程 c. 每对通信过程之间可以有多少个链接 d.链接容量是多少？链接可以容纳的消息大小是固定的还是可变的 e. 链接是单向的还是双向的

通过消息交换的方式传递信息：

a. 同步 b. 异步

客户端/服务端的通信有：

Pipe

socket

Remote Procedural calls (RPCs)

生产者-消费者模式

**管道**(Pipe):用于父进程和子进程间的通信

**有名管道(named pipe/FIFO)**:用于运行于同一系统中的任意两个进程间的通信

**信号**(signal):kill(向任意进程发送信号)、raise(只能向当前进程发送信号)、abort(发送SIGABRT信号，可以让进程异常终止)、alarm(发送SIGALRM闹钟信号)

**信号量(Semaphore)**:主要用途是**保护临界资源。**进程可以根据它来判定是否能够访问某些共享资源;除了用于访问控制外，**还可用于进程同步**

**共享内存(Share Memory)**:共享内存允许一个或多个进程共享一个给定的物理存储区，这一个给定的物理存储区可以被两个或两个以上的进程映射至自身的地址空间中。一个进程写共享内存时候，另一个不可以读，通过信号量实现共享内存访问。

**消息队列(Message queues)**:消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息;消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。

**套接字**：可以用于不同机器的进程间通信

**存储映射IO(Memory Map)**:存储映射函数mmap，通过映射一个普通的文件实现共享内存（将文件映射到虚拟内存上，通过访问修改内存，实现访问修改文件）;共享内存与存储映射IO比较：mmap在磁盘上建立一个文件，每个线程的地址空间开辟一块空间进行映射，而共享内存是共享一块物理内存区域，所mmap映射文件保存在硬盘上，不会丢失，而共享内存会丢失。

### 31. 线程同步和线程互斥的区别

1. 互斥是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
2. 同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。
3. 同步其实已经实现了互斥，所以同步是一种更为复杂的互斥。
4. 互斥是一种特殊的同步。

总的来说，两者的区别就是：
互斥是通过竞争对资源的独占使用，彼此之间不需要知道对方的存在，执行顺序是一个乱序。
同步是协调多个相互关联线程合作完成任务，彼此之间知道对方存在，执行顺序往往是有序的。

lock与unlock方法，替换synchronized，这就是互斥锁的体现。消费者生产者模式就是同步锁的体现。

### 32. 静态链表和动态链表的区别

静态链表和动态链表的共同点是，数据之间"一对一"的逻辑关系都是依靠指针（静态链表中称"游标"）来维持，仅此而已。

静态链表是用类似于数组方法来实现的，是顺序的存储结构，在物理地址上是连续的，而且需要预先分配地址空间的大小。所以静态链表的初始长度一般是固定的，在做插入和删除操作时不需要移动元素，仅需修改指针。

动态链表是用内存申请函数（malloc/new）动态申请内存的，所以在链表的长度上没有限制。动态链表因为是动态申请内存的，所以每个节点的物理地址不连续，要通过指针来顺序访问。

静态链表好处：

1 节约频繁的分配/删除内存的时间
2 在内存分配和使用上更安全(避免溢出和分配失败)

### 33. 孤儿进程和僵尸进程

孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

僵尸进程危害场景：unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。 但这样就导致了问题，**如果进程不调用wait / waitpid的话，** **那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。**

**孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上**，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。**因此孤儿进程并不会有什么危害。**

**任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。**这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。

https://www.cnblogs.com/Anker/p/3271773.html

### 34. 同步IO和异步IO的区别？

IO分两阶段：

1.数据准备阶段  

2.内核空间复制回用户进程缓冲区阶段

一般来讲：阻塞IO模型、非阻塞IO模型、IO复用模型(select/poll/epoll)、信号驱动IO模型都属于同步IO，因为阶段2是阻塞的(尽管时间很短)。只有异步IO模型是符合POSIX异步IO操作含义的，不管在阶段1还是阶段2都可以干别的事。

**阻塞IO**:使用recv的默认参数一直等数据直到拷贝到用户空间，这段时间内进程始终阻塞。

**非阻塞IO**:改变flags，让recv不管有没有获取到数据都返回，如果没有数据那么一段时间后再调用recv看看，如此循环

**同步IO**：IO的读写操作在IO事件发生之后，由应用程序来完成

**异步IO(AIO)**：用户可以直接对IO执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及IO操作完成之后内核通知应用程序的方式，异步IO的读写操作总是立即返回的

https://www.cnblogs.com/euphie/p/6376508.html

### 35. 智能指针 auto_ptr、shared_ptr、weak_ptr和unique_ptr

https://www.cnblogs.com/wxquare/p/4759020.html

https://www.cnblogs.com/zeppelin5/p/10083597.html

C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。

智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。

#### auto_ptr

auto_ptr这是C++98标准下的智能指针，现在常常已经被C++标准的其他智能指针取代。**它的缺点是在转移所有权后会使运行期不安全**（auto_ptr存在拷贝构造函数和赋值构造函数，拷贝后会将原指针置为null）。

体现在两个场景：

1. 使用vector等容器存储auto_ptr,对容器中的数据进行拷贝时，会将容器中的数据置为null，访问的时候会导致段错误。
2. auto_ptr作为函数参数时，会将传入的数据置为null，导致访问时出现段错误。

C++11新标准，用unique_ptr来代替auto_ptr原有功能，unique_ptr禁用了拷贝构造和赋值构造。

1. 不建议在vector中使用unique_ptr
2. 最为参数时，传递unique_ptr引用或裸指针

```cpp
#include <iostream>
#include <memory>
#include <string>
using namespace std;

void main(){
    auto_ptr<string> country[5] =
    {
        auto_ptr<string>(new string("USA")),
        auto_ptr<string>(new string("CHN")),
        auto_ptr<string>(new string("RUS")),
        auto_ptr<string>(new string("FRA")),
        auto_ptr<string>(new string("GRB"))
    };
    auto_ptr<string> pwin;
    pwin = country[2]; //将所有权从country[2]转让给pwin，
                       //此时country[2]不再引用该字符串从而变成空指针，在运行到循环时就会崩溃
    for (int i = 0; i < 5; ++i)
        cout << *country[i] << endl;//运行到[2]时崩溃，因为country[2]为空
    cout << "The best is " << *pwin << endl;
    system("pause");
}
```

#### unique_ptr

unique_ptr 是一个独享所有权的智能指针，它提供了严格意义上的所有权。它取代了C++98中的auto_ptr。

相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。

unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。

unique_ptr没有use_count()方法

```cpp
#include <iostream>
#include <memory>
#include <string>
using namespace std;

unique_ptr<string> fun2(){
    return unique_ptr<string>(new string("RUS"));
}

void fun(){
    unique_ptr<string> pa(new string("CHN"));
    unique_ptr<string> pb(new string("USA"));
    pb = move(pa); //p2=p1;错误，不能直接用等于号;智能指针转移，pa为null，pb为pa指向的内存地址
    if (pa == nullptr)
        cout << "pa现在为空" << endl;
    cout << "*pb " << *pb << endl;//pb变成了“CHA”
    string* ps = pb.release();//清空当前智能指针,并返回指针
    cout << "*ps " << *ps << endl;//ps变成了“CHA”
    pa.reset(ps);//使用指针重置智能指针
    cout << "*pa " << *pa << endl;//pa变成了“CHA”
    pb = fun2();//接收函数的返回值可以用等于号，因为使用了移动构造函数
    cout << "*pb " << *pb << endl;//pb变成了“RUS”
}
void main()
{
    fun();
    system("pause");
}
```

```cpp
//代码返回一个资源，如果我们不显式捕获返回值，该资源将被清除。
unique_ptr <A> fun（）
{ 
    unique_ptr <A> ptr（new A）; 

    / * ... 
       ... * /

    返回ptr; 
}
```

- weak_ptr用于解决“引用计数”模型**循环依赖**问题，weak_ptr指向一个对象，并不增减该对象的引用计数器
- weak_ptr指向shared_ptr指针指向的对象的内存，却并不拥有该内存。 
  但是，使用weak_ptr成员lock，则可返回其指向内存的一个shared_ptr对象，且在所指对象内存已经无效时，返回指针空值（nullptr）。由于weak_ptr是指向shared_ptr所指向的内存的，所以，weak_ptr并不能独立存在。
- 在使用weak_ptr时也要当心,时刻需要判断weak_ptr对应的shared_ptr是否为空,weak_ptr并不会增加shared_ptr的引用计数.

#### shared_ptr

share_ptr是C++11新添加的智能指针，它限定的资源可以被多个指针共享

shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。

* 初始化。智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。
* 拷贝和赋值。拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象。
* get函数获取原始指针
* 注意不要用一个原始指针初始化多个shared_ptr，否则会造成二次释放同一内存
* 注意避免循环引用，shared_ptr的一个最大的陷阱是循环引用，循环引用会导致堆内存无法正确释放，导致内存泄漏。

```cpp
#include <iostream>
#include <memory>

int main() {
    {
        int a = 10;
        std::shared_ptr<int> ptra1(new int(10));
        std::shared_ptr<int> ptra = std::make_shared<int>(a);
        std::shared_ptr<int> ptra2(ptra); //copy
        std::cout << ptra.use_count() << std::endl;
        ptra2 = ptra1; //ptra引用减1，ptra1引用加1

        int b = 20;
        int *pb = &a;
        //std::shared_ptr<int> ptrb = pb;  //error
        std::shared_ptr<int> ptrb = std::make_shared<int>(b);
        ptra2 = ptrb; //assign
        pb = ptrb.get(); //获取原始指针

        std::cout << ptra.use_count() << std::endl;
        std::cout << ptrb.use_count() << std::endl;
    }
}
```

#### weak_ptr

weak_ptr是为了配合shared_ptr而引入的一种智能指针，因为它不具有普通指针的行为，没有重载operator*和->,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况。

weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。使用weak_ptr的成员函数use_count()可以观测资源的引用计数，另一个成员函数expired()的功能等价于use_count()==0,但更快，表示被观测的资源(也就是shared_ptr的管理的资源)已经不复存在。

weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象， 从而操作资源。但当expired()==true的时候，lock()函数将返回一个存储空指针的shared_ptr。

weak_ptr是一种用于解决shared_ptr相互引用时产生死锁问题的智能指针。如果有两个shared_ptr相互引用，那么这两个shared_ptr指针的引用计数永远不会下降为0，资源永远不会释放。weak_ptr是对对象的一种弱引用，它不会增加对象的use_count，weak_ptr和shared_ptr可以相互转化，shared_ptr可以直接赋值给weak_ptr，weak_ptr也可以通过调用lock函数来获得shared_ptr。

```cpp
#include <iostream>
#include <memory>

int main() {
    {
        std::shared_ptr<int> sh_ptr = std::make_shared<int>(10);
        std::cout << sh_ptr.use_count() << std::endl;

        std::weak_ptr<int> wp(sh_ptr);
        std::cout << wp.use_count() << std::endl;

        if(!wp.expired()){
            std::shared_ptr<int> sh_ptr2 = wp.lock(); //get another shared_ptr
            *sh_ptr = 100;
            std::cout << wp.use_count() << std::endl;
        }
    }
    //delete memory
}
```

**循环引用**

```cpp
#include <iostream>
#include <memory>

class Child;
class Parent;

class Parent {
private:
    //std::shared_ptr<Child> ChildPtr;
    std::weak_ptr<Child> ChildPtr;
public:
    void setChild(std::shared_ptr<Child> child) {
        this->ChildPtr = child;
    }

    void doSomething() {
        //new shared_ptr
        if (this->ChildPtr.lock()) {
        }
    }
    ~Parent() {
    }
};

class Child {
private:
    std::shared_ptr<Parent> ParentPtr;
public:
    void setPartent(std::shared_ptr<Parent> parent) {
        this->ParentPtr = parent;
    }
    void doSomething() {
        if (this->ParentPtr.use_count()) {
        }
    }
    ~Child() {
    }
};

int main() {
    std::weak_ptr<Parent> wpp;
    std::weak_ptr<Child> wpc;
    {
        std::shared_ptr<Parent> p(new Parent);
        std::shared_ptr<Child> c(new Child);
        p->setChild(c);
        c->setPartent(p);
        wpp = p;
        wpc = c;
        std::cout << p.use_count() << std::endl; // 2
        std::cout << c.use_count() << std::endl; // 1
    }
    std::cout << wpp.use_count() << std::endl;  // 0
    std::cout << wpc.use_count() << std::endl;  // 0
    return 0;
}
```

### 36. 锁

#### lock_gurad

lock_guard 对象通常用于管理某个锁(Lock)对象；

在 lock_guard 对象构造时，传入的 Mutex 对象(即它所管理的 Mutex 对象)会被当前线程锁住。在lock_guard 对象被析构时，它所管理的 Mutex 对象会自动解锁，由于不需要程序员手动调用 lock 和 unlock 对 Mutex 进行上锁和解锁操作，因此这也是最简单安全的上锁和解锁方式，尤其是在程序抛出异常后先前已被上锁的 Mutex 对象可以正确进行解锁操作，极大地简化了程序员编写与 Mutex 相关的异常处理代码

值得注意的是，lock_guard 对象并不负责管理 Mutex 对象的生命周期，lock_guard 对象只是简化了 Mutex 对象的上锁和解锁操作，方便线程对互斥量上锁

#### unique_lock

 lock_guard 最大的缺点也是简单，没有给程序员提供足够的灵活度。unique_lock，与 lock_guard 类相似，也很方便线程对互斥量上锁，但它提供了更好的上锁和解锁控制。

unique_lock 对象以独占所有权的方式（ unique owership）管理 mutex 对象的上锁和解锁操作，所谓独占所有权，就是没有其他的 unique_lock 对象同时拥有某个 mutex 对象的所有权

std::unique_lock 对象也能**保证在其自身析构时它所管理的 Mutex 对象能够被正确地解锁**（即使没有显式地调用 unlock 函数）。因此，和 lock_guard 一样，这也是一种简单而又安全的上锁和解锁方式，尤其是在程序抛出异常后先前已被上锁的 Mutex 对象可以正确进行解锁操作，极大地简化了程序员编写与 Mutex 相关的异常处理代码。

值得注意的是，unique_lock 对象同样也不负责管理 Mutex 对象的生命周期，unique_lock 对象只是简化了 Mutex 对象的上锁和解锁操作，方便线程对互斥量上锁

#### shared_lock

shared_lock 是通用**共享互斥所有权包装器（unique_lock则是独占互斥所有权包装器）**，允许延迟锁定、定时锁定和锁所有权的转移。**锁定 shared_lock ，会以共享模式锁定关联的共享互斥**（`std::unique_lock` 可用于以排他性模式锁定）

方法和unique_lock一样，用法也相同

### 36. C++中4种cast

#### const_cast

用法：const_cast<type_id> (expression)
  该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。
**常量指针被转化成非常量指针**，并且仍然指向原来的对象；
**常量引用被转换成非常量引用**，并且仍然指向原来的对象；常量对象被转换成非常量对象。

**const_cast强制转换对象必须为指针或引用**

#### static_cast

用法：static_cast <类型说明符> （变量或表达式）

它主要有如下几种用法：
  （1）用于类层次结构中**基类和派生类之间指针或引用的转换**
   进行上行转换（把派生类的指针或引用转换成基类表示）是安全的
   进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的
  （2）用于**基本数据类型之间的转换**，如把int转换成char。这种转换的安全也要开发人员来保证
  （3）把**空指针转换成目标类型的空指针**
  （4）把**任何类型的表达式转换为void类型**
  注意：static_cast不能转换掉expression的const、volitale或者__unaligned属性。

#### dynamic_cast

dynamic_cast<type_id> (expression)

（1）其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。

（2）用于类层次结构中**基类和派生类之间指针或引用的转换**

（3）不能用于内置的基本数据类型的强制转换。

（4）dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。

（5）使用**dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过**。

需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义

（6）在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。

#### reinterpret_cast

reinterpret_cast几乎什么都可以转，可能会出问题，尽量少用。

reinterpret_cast主要有三种强制转换用途：改变指针或引用的类型、将指针或引用转换为一个足够长度的整形、将整型转换为指针或引用类型。

用法：reinterpret_cast<type_id> (expression)

type-id必须是一个指针、引用、算术类型、函数指针或者成员指针。
  它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。
  在使用reinterpret_cast强制转换过程仅仅只是比特位的拷贝，因此在使用过程中需要特别谨慎！

#### 为什么不使用C的强制转换

C的强制转换表面上看起来功能强度大，什么都能转，但转换不够明确，不能进行错误检查，容易出错。

### 37. 只在堆或栈上实例化对象

对象创建两种方式：

**1 静态创建**

由编译器在栈中为对象分配内存，通过移动栈顶指针获得合适大小的空间，然后**调用对象的构造函数生成**对象。

**2 动态创建**

通过new在堆中创建对象。这个过程分为两步：首先在堆中找到合适大小的空间并分配，然后**调用对象的构造函数**生成对象。

**只在堆上创建对象**：将析构函数设为私有

**只在栈上创建对象**：将 **new操作符重载并设置为私有访问**即可

https://blog.csdn.net/qq_30835655/article/details/68938861

### 38. 各类型占用字节数

32位编译器：

| char | short | int | long | long long | float | double | 指针  |
| ---- | ----- | --- | ---- | --------- | ----- | ------ | --- |
| 1    | 2     | 4   | 4    | 8         | 4     | 8      | 4   |

64位编译器：

| char | short | int | long | long long | float | double | 指针  |
| ---- | ----- | --- | ---- | --------- | ----- | ------ | --- |
| 1    | 2     | 4   | 8    | 8         | 4     | 8      | 8   |

### 39. auto

auto 根据`=`右边的初始值 value 推导出变量的类型

1. 使用 auto 的时候必须对变量进行初始化
2. auto 不能在函数的参数中使用
3. auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中。
4. auto 关键字不能定义数组
5. auto 不能作用于模板参数

使用场景：

1. 使用 auto 定义迭代器
2. auto 用于泛型编程

### 40. decltype

在编译时期进行自动类型推导

```cpp
decltype(exp) varname = value;
```

**推导规则**:

- 如果 exp 是一个不被括号`( )`包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。
- 如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。
- 如果 exp 是一个左值，或者被括号`( )`包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&。

### 41. auto和decltype区别

```cpp
auto varname = value;  //auto的语法格式
decltype(exp) varname [= value];  //decltype的语法格式
```

1. auto 根据`=`右边的初始值 value 推导出变量的类型；decltype 根据 exp 表达式推导出变量的类型，跟`=`右边的 value 没有关系。
2. auto 要求变量必须初始化，也就是在定义变量的同时必须给它赋值；而 decltype 不要求，初始化与否都不影响变量的类型。
3. decltype 会保留 cv(const和volatile) 限定符，而 auto 有可能会去掉 cv 限定符。
4. 当表达式的类型为引用时，decltype 会保留引用类型，而 auto 会抛弃引用类型，直接推导出它的原始类型
5. auto 只能用于类的静态成员，不能用于类的非静态成员（普通成员），如果我们想推导非静态成员的类型，这个时候就必须使用 decltype 了

### 42. 单例模式

```cpp
class Singleton
{
  private:

    Singleton(){
        cout << "构造" << endl;
    };
    ~Singleton(){
        cout << "析构" << endl;
    };

  public:
    static Singleton *getInstance()
    {
        static Singleton locla_s;
        return &locla_s;
    }
};
```

https://www.jianshu.com/p/7ca3af70130c

或者使用pthread_once用线程初始化对象，使用pthread库保证线程安全

### 43. 泛型

泛型在C++中的主要实现为模板函数和模板类。

**函数模板的性质**

1) 函数模板并不是真正的函数，它只是C++编译生成具体函数的一个模子。
2) 函数模板本身并不生成函数，实际生成的函数是替换函数模板的那个函数，比如上例中的add(sum1,sum2)，
    这种替换是编译期就绑定的。
3) 函数模板不是只编译一份满足多重需要，而是为每一种替换它的函数编译一份。
4) 函数模板不允许自动类型转换。
5) 函数模板不可以设置默认模板实参。比如template \<typename T=0\>不可以。

**类模板的性质**

1) 类模板不是真正的类，它只是C++编译器生成具体类的一个模子。
2) 类模板可以设置默认模板实参。

### 44. friend

友元的作用是提高了程序的运行效率（即减少了类型检查和安全性检查等都需要时间开销），但它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。

* 友元函数
  
  友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以
  
  声明，声明时只需在友元的名称前加上关键字friend
  
  友元函数的声明可以放在类的私有部分，也可以放在公有部分，它们是没有区别的，都说明是该类的一个友元函数。
  
  一个函数可以是多个类的友元函数，只需要在各个类中分别声明。友元函数的调用与一般函数的调用方式和原理一致。
  
  友元函数并不是类的成员函数，因此在类外定义的时候不能加上class::function name
  
  ```cpp
  class Point//声明
  {
  　　public:
  　　　　Point(double xx, double yy) { x=xx; y=yy; }//默认构造函数
  　　　　void Getxy();//公有成员函数
  　　　　friend double Distance(Point &a, Point &b);//友元函数
  　　private:
  　　　　double x, y;
  };
  
  void Point::Getxy()
  {
  　　cout<<"("<<x<<","<<y<<")\n";
  }
  
  double Distance(Point &a, Point &b)  //注意函数名前未加类声明符
  {
  　　double dx = a.x - b.x;
  　　double dy = a.y - b.y;
  　　return sqrt(dx*dx+dy*dy);
  }
  void main()
  {
  　　Point p1(3.0, 4.0), p2(6.0, 8.0);
  　　p1.Getxy();
  　　p2.Getxy();
  　　double d = Distance(p1, p2);
  　　cout<<"Distance is"<
  }
  ```

* 友元类
  
  友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。当希望一个
  
  类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。
  
  友元关系不能被继承
  
  友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。
  
  友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明 
  
  ```cpp
  //B类为A类的友元类，可以访问A中的成员
  class A {
  private:
      int a1;    
  public:
      friend class B;
      void pp() {
          cout << a1;
      }
  };
  
  class B {
  private:
      int b1;
  public:
      void pp(const A &a) {
          cout << a.a1 << endl;  //访问A类中的私有成员
      }
  };
  ```

### 45. 静态库

  静态库是使用“ar”压缩程序将目标文件压缩到一起，并且对其进行编号和索引

```shell
$ar -t libc.a  #查看静态库中包含的目标文件
init-first.o
libc-start.o
...
$ar –x libc.a #解压静态库
```

### 46. fork和exec区别

  **fork**：新的进程与旧的进程使用同一个代码段，因为它们的程序还是相同的，对于数据段和堆栈段，系统则复制一份给新的进程，这样，父进程的所有数据都可以留给子进程，但是，子进程一旦开始运行，虽然它继承了父进程的一切数据，但实际上数据却已经分开，相互之间不再有影响了，也就是说，它们之间不再共享任何数据了。而如果两个进程要共享什么数据的话，就要使用另一套函数（shmget，shmat，shmdt等）来操作。对于父进程，fork函数返回了子程序的进程号，而对于子程序，fork函数则返回零，这样，对于程序，只要判断fork函数的返回值，就知道自己是处于父进程还是子进程中。

  **exec**：一个进程一旦调用exec类函数，它本身就“死亡”了，系统把代码段替换成新的程序的代码，废弃原有的数据段和堆栈段，并为新程序分配新的数据段与堆栈段，唯一留下的，就是进程号，也就是说，对系统而言，还是同一个进程，不过已经是另一个程序了。不过exec类函数中有的还允许继承环境变量之类的信息，这个通过exec系列函数中的一部分函数的参数可以得到

### 47. 左值和右值

  左值：能对表达式取地址、或具名对象/变量。

  右值：不能对表达式取地址、或匿名对象。

```cpp
int x = 666;  //x为左值，666为右值
int* y = &x;  //对于左值x，你可以做像这样的操作
666 = x; //error!
int* y = &666;//error  赋值的左操作数需要一个左值，这里我们使用了一个右值666
int y = 10;
int& yref = y;
yref++;        //左值引用
int& ref = 10;  // error
const int& ref = 10;  // OK!常量左值引用  可以将一个const的左值绑定到一个右值上

//C++中经常通过常量引用来将值传入函数中，这避免了不必要的临时对象的创建和拷贝
```

  https://www.jianshu.com/p/94b0221f64a5

  通过右值引用和移动，实现类的移动拷贝构造函数和移动拷贝复制运算符，消除两个对象赋值时的不必要的对象拷贝。

  https://www.jianshu.com/p/31cea1b6ee24

### 48. C++11新特性

1. auto关键字
2. nullptr关键字
3. 智能指针
4. 初始化列表
5. 右值引用，完美转发
6. lambda匿名函数

### 49. lambda函数

```text
[外部变量访问方式说明符] (参数) mutable noexcept/throw() -> 返回值类型
{
   函数体;
};
```

1. [ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。
   
   可以传值或者引用：
   
   [x,&y]  引入x的值和y的引用
   
   [=,&y] 引入y的引用和其他所有对象，= 表示所有。

2. (参数)和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；

3. mutable  此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。  
   
   注意，对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；

4. noexcept/throw()  可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型

5. -> 返回值类型    指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略`-> 返回值类型`。

6. 函数体    和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量

### 50. socket中TCP和UDP连接端口号是否可以相同

可以，但两个TCP不能共用一个端口号，两个UDP也不可共用相同的端口号

### 51. using用法

1. 引用子命名空间、引用基类成员
2. 导入命名空间
3. 命名空间别名，列别名

```cpp
//using 声明 (using declaration) 是将命名空间中单个名字注入到当前作用域的机制，使得在当前作用域下访问另一个作用域下的成员时无需使用限定符 ::
using std::map;
// 命令空间导入
using namespace std;
// 命令空间别名
using TorchModule = torch::jit::script::Module;
using Tensor = torch::Tensor;
namespace http = beast::http; 
//类型重定义，取代 typedef(别名)
using fun = void (*)(int, int);
//typedef void (*fun)(int, int); //与上一句等价
using int16 = short;
//typedef short int16; //与上一句等价
```

```cpp
#include <iostream>
// 引入命名空间
using namespace std;

class ClassOne {
public:
    int w;
protected:
    int a;
};

class ClassTwo{
public:
    using ModuleType = ClassOne;  //别名
};

template <typename ClassType>
class ClassThree : private ClassType{
public:
    //在子类中引用基类的成员
    using typename ClassType::ModuleType;
    ModuleType m;
    ClassThree() = default;
    virtual ~ClassThree() = default;
};

void main(){
    ClassThree<ClassTwo>::ModuleType a;
}
```

### 52. size_t,ssize_t

在sys/types.h中定义

size_t是通过typedef声明的unsigned int类型

ssize_t是通过typedef声明的signed int类型

### 53 const和constexpr

const并未区分出编译期常量和运行期常量
**constexpr**是[C++11](https://zh.wikipedia.org/wiki/C%2B%2B11)引入的[关键字](https://zh.wikipedia.org/wiki/關鍵字)，用于[编译时](https://zh.wikipedia.org/wiki/编译时)的常量与常量函数。

声明为constexpr函数的意义是：如果其参数均为合适的编译期常量，则对这个constexpr函数的调用就可用于期望常量表达式的场合（如模板的非类型参数，或枚举（enum）常量的值）。如果参数的值在运行期才能确定，或者虽然参数的值是编译期常量，但不匹配这个函数的要求，则对这个函数调用的求值只能在运行期进行。

`constexpr`函数必须满足下述限制：

- 函数返回值不能是void类型
- 函数体不能声明变量或定义新的类型
- 函数体只能包含声明、null语句或者一段return语句
- 在形参实参结合后，return语句中的表达式为常量表达式

```cpp
#include <iostream>
#include <array>
using namespace std;

constexpr int foo(int i)
{
    return i + 5;
}

int main()
{
    int i = 10;
    std::array<int, foo(5)> arr; // OK

    foo(i); // Call is Ok

    // But...
    std::array<int, foo(i)> arr1; // Error

}
```

[参考](https://zh.wikipedia.org/wiki/Constexpr)

### 54. tcmalloc

google tcmalloc相对于glibc 2.3中的ptmalloc2有很大的性能提升，现在最新的glibc中的ptmalloc3已经把差距大大缩小了

### 55. __thread

C++ 11使用thread_local

线程局部存储(tls)是一种机制,通过这一机制分配的变量,**每个当前线程有一个该变量的实例**

__thread不能修饰class类型，因为无法自动调用构造函数和析构函数。不能用于修饰函数的局部变量或者class的普通成员变量

__thread可以用于修饰全局变量、函数内的静态变量

__thread变量的初始化只能用编译期常量。

```cpp
__thread string t_obj1("111"); //错误，不能调用对象的析构函数
__thread string* t_obj2 = new string; // 错误，初始化必须用编译器常量
__thread string* t_obj3 = NULL;  // 正确，但是需要手工初始化并销毁对象
```

### 56. \__attribute__作用

**attribute**可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute)等.

```cpp
typedef struct
{
    char  member1;
    int   member2;
    short member3;
}__attribute__ ((aligned(8))) Family;  //结构体8字节对齐
```

### 57. 什么时候必须用单线程

1. 程序可能会fork()
2. 限制程序的cpu占用率

### 58. C++状态码设计

```cpp
namespace BASE{

class CodeEnum {
 public:
  CodeEnum(int code, std::string message) : _code(code), _message(message) {}
  int GetCode() const {
    return _code;
  }
  std::string GetMessage() const {
    return _message;
  }

  bool operator==(const CodeEnum &other) {
    return _code == other._code;
  }

  bool operator!=(const CodeEnum &other) {
    return _code != other._code;
  }

 private:
  int _code;
  std::string _message;
};

namespace Status{

const CodeEnum SUCCESS(2000, "SUCCESS");
const CodeEnum ERROR(9999, "ERROR");

};

};
//使用：
// Status::SUCCESS.GetCode()
// Status::SUCCESS.GetMessage()
```
