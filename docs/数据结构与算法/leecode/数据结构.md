# 数据结构

## 二维数组查找

```text
已知int一个有序矩阵mat，同时给定矩阵的大小n和m以及需要查找的元素x，且矩阵的行和列都是从小到大有序的。设计查找算法返回所查找元素的二元数组，代表该元素的行号和列号(均从零开始)。保证元素互异。
```

```text
思路：
首先选取矩阵中右上角的数字，如果该数字等于要查找的数字，查找结束，如果该数字大于要查找的数组，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。
同理从左下角开始查找也可以
```

```cpp
vector<int> findElement(vector<vector<int> > mat, int n, int m, int x) {
        // write code here
        vector<int> res;
        int row=0,col=m-1;
        while(row<n && col>=0){
            if(mat[row][col]==x){
                res.push_back(row);
                res.push_back(col);
                return res;
            }else if(mat[row][col]>x){
                col--;
            }else{
                row++;
            }
        }
        return res;
}
```

## 二分查找

### 查找值

```cpp
int binary_search(vector<int> nums,int target){
    if(nums.size()==0) return -1;
    int left=0,right=nums.size()-1;
    while(left<=right){
        int mid = (left+right)/2;
        if(nums[mid]==target){
            return mid;
        }else if(nums[mid]>target){
            left = mid +1;
        }else{
            right = mid - 1;
        }
    }
    return -1;
}
```

### 查找左边界

```cpp
int left_bound(vector<int> nums,int target){
    if(nums.size()==0) return -1;
    int left=0,right=nums.size()-1;
    while(left<=right){
        int mid = (left+right)/2;
        if(nums[mid]==target){
            right = mid -1;
        }else if(nums[mid]>target){
            left = mid +1;
        }else{
            right = mid - 1;
        }
    }
    if(left>=nums.size || nums[left]!=target)
        return -1;
    return left;
}
```

### 查找右边界

```cpp
int right_bound(vector<int> nums,int target){
    if(nums.size()==0) return -1;
    int left=0,right=nums.size()-1;
    while(left<=right){
        int mid = (left+right)/2;
        if(nums[mid]==target){
            left = mid +1;
        }else if(nums[mid]>target){
            left = mid +1;
        }else{
            right = mid - 1;
        }
    }
    if(right<0 || nums[right]!=target)
        return -1;
    return right;
}
```



### 旋转数组最小值(二分)

```text
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
```

```text
这里我们把target 看作是右端点，来进行分析，那就要分析以下三种情况，看是否可以达到上述的目标。

情况1，arr[mid] > target：4 5 6 1 2 3
arr[mid] 为 6， target为右端点 3， arr[mid] > target, 说明[first ... mid] 都是 >= target 的，因为原始数组是非递减，所以可以确定答案为 [mid+1...last]区间,所以 first = mid + 1
情况2，arr[mid] < target:5 6 1 2 3 4
arr[mid] 为 1， target为右端点 4， arr[mid] < target, 说明答案肯定不在[mid+1...last]，但是arr[mid] 有可能是答案,所以答案在[first, mid]区间，所以last = mid;
情况3，arr[mid] == target:
如果是 1 0 1 1 1， arr[mid] = target = 1, 显然答案在左边
如果是 1 1 1 0 1, arr[mid] = target = 1, 显然答案在右边
所以这种情况，不能确定答案在左边还是右边，那么就让last = last - 1;慢慢缩少区间，同时也不会错过答案。
```

```cpp
int minNumberInRotateArray(vector<int> rotateArray) {
        if(rotateArray.size()==0) return 0;
        int first=0,last=rotateArray.size()-1;
        while(first<last){
            if(rotateArray[first]<rotateArray[last]){  //未进行旋转
                return rotateArray[first];
            }
            int mid = (first+last)/2;
            if(rotateArray[mid]>rotateArray[last]){  //最小元素位于mid右侧
                first = mid +1;
            }else if(rotateArray[mid]<rotateArray[last]){  //mid可能是最小的元素
                last = mid;
            }else{
                --last;
            }
        }
        return rotateArray[first];
}
```

### 旋转数组查找(二分)

```text
给出一个转动过的有序数组，你事先不知道该数组转动了多少
(例如,0 1 2 4 5 6 7可能变为4 5 6 7 0 1 2).
在数组中搜索给出的目标值，如果能在数组中找到，返回它的索引，否则返回-1。
假设数组中不存在重复项。
```

```text
对旋转数组进行均等划分后，总有一边是有序的
我们定位到有序的一边后，对比target与有序子数组的左右边界，就可以作出搜索左侧还是右侧的决策。
```

```cpp
int search(int* A, int n, int target) {
        // write code here
        int left = 0, right = n - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (A[mid] == target) return mid;
            if (A[mid] >= A[left]) {
                // 左侧有序(含A[mid])
                if (A[mid] > target && A[left] <= target)
                    right = mid - 1;
                else
                    left = mid + 1;
            } else {
                // 右侧有序(含A[mid])
                if (A[mid] < target && A[right] >= target)
                    left = mid + 1;
                else
                    right = mid - 1;
            }
        }
        return -1;
}
```

## 数组中重复的数字

```text
在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有哪几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2，3，1，0，2，5，3}，那么对应的输出是重复的数字2或者是3。
```

```text
数组里所有的数组都是0到n-1的范围内。如果数组里没有重复的数字，那么每个数字排序后的数字i都会在下标为i的位置上。由于数组中有重复的数字，那么这个位置上就会有多个数字，有些位置上也会没有数字。
从头到尾扫描这个数组的每个数字。当到下标为i的数字时，先比较这个数字m是否等于下标i，如果等于那么就扫描下一个数字；如果不是，那它和第m个数字相比较。如果和第m个数字一样，则找到重复的数字，因为该数字在第i个位置和第m个位置都出现了；如果不是则把该第i位置上的数字和第m个位置上的数字交换，刚在它原本属于的位置上去。重复此过程，找到重复的数字。
```

```cpp
bool duplicate(int nums[],int len,int *duplication){
      if(nums==nullptr || len<0){
          return false;
      }
      for(int i=0;i<len;i++){
          if(nums[i]<0 || nums[i]>len-1)
              return false;
      }
      for(int i=0;i<len;i++){
          while(nums[i]!=i){
              if(nums[i]==nums[nums[i]]){
                  *duplication = nums[i];
                  return true;
              }else{
                  swap(nums[i],nums[nums[i]]);
              }
          }
      }
}
```

## 替换空格

```text
请实现一个函数，把字符串中的每个空格替换成"%20"。例如输入“We are happy.”，则输出“We%20are%20happy.”。　
```

```text
Step1.先遍历一次字符串，这样就能统计出字符串中空格的总数，并可以由此计算出替换之后的字符串的总长度。
Step2.从字符串的后面开始复制和替换。
```

```cpp
void ReplaceBlank(char str[],int len){
    if(str==nullptr || len<=0)
        return;
    int originalLen=0,blankCount=0;
    int i=0;
    while(str[i++]!='\0'){
        originalLen++;
        if(str[i]==' ')
            blankCount++;
    }
    int newLen = originalLen + 2*blankCount;
    if(newLen>len)
        return;
    int index1 = originalLen;
    int index2 = newLen;
    while(index1>=0 && index2>=0){
        if(str[index1]==' '){
            str[index2--] = '0';
            str[index2--] = '2';
            str[index2--] = '%';
            index1--;
        }else{
            str[index2--] = str[index1--];
        }
    }
}
```

## 从尾到头打印链表

```text
输入一个链表的头结点，从尾到头反过来打印出每个结点的值。
```

```text
解法一：反转链表，再从头打印，需要修改原链表内容
解法二：先遍历一遍链表，将数据记录在栈中，再从栈中弹出数据，不修改原链表的内容，增加了一个容量为N的栈
解法三：使用递归，访问每个节点的时候先递归输出后面的节点，但是当链表非常长的时候，可能会导致调用栈溢出。
```

## 重建二叉树--分治、递归

```text
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
```

```text
从前序遍历可知，前序遍历数组pre的首元素就是二叉树的根结点，然后根据根结点的值在中序遍历中找到根结点的位置，那么根结点左边就为左子树的序列，根结点右边就是右子树的序列。
使用同样的方法构建左右子树。
```

```cpp
TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        return rebuild(pre, 0, pre.size()-1, vin, 0, vin.size()-1);
}
    
TreeNode *rebuild(vector<int> &pre,int pre_l,int pre_r,vector<int> &vin,int vin_l,int vin_r){
        if(pre_l>pre_r) return nullptr;
        TreeNode *root = new TreeNode(pre[pre_l]);
        int root_index;
        for(root_index=vin_l;root_index<=vin_r;root_index++){
            if(vin[root_index]==root->val)
                break;
        }
        root->left= rebuild(pre, pre_l+1, pre_l+root_index-vin_l, vin, vin_l, root_index-1);
        root->right = rebuild(pre, pre_l+root_index-vin_l+1, pre_r, vin, root_index+1, vin_r);
        return root;
}
```

## 二叉树的下一个节点

```text
给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
```

```text
1.node节点有右孩子。下一个结点就是以node结点的右孩子为根的子树中的最左下结点
2.node 节点没有右孩子时，node节点是其父结点的左孩子。
3.node 节点没有右孩子时，node节点是其父结点的右孩子，可以沿着指向父节点的指针一直向上遍历，直到找到一个是它父节点的左子节点的节点，如果存在即为下一个节点，否则为空。
```

## 两个栈实现队列

```text
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
```

```text
push操作就直接往stack1中push， pop操作需要分类一下：如果stack2为空，那么需要将stack1中的数据转移到stack2中，然后在对stack2进行pop，如果stack2不为空，直接pop就ok。
```

```cpp
class Solution
{
public:
    void push(int node) {
        stack1.push(node);
    }

    int pop() {
        if(stack2.empty()){
            while(!stack1.empty()){
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
        int ret = stack2.top();
        stack2.pop();
        return ret;
    }

private:
    stack<int> stack1;
    stack<int> stack2;
};
```

## 包含min函数的栈

```
定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））
```

```cpp
class Solution {
    stack<int> st;
    stack<int> mi;
public:
    void push(int value) {
        st.push(value);
        if(mi.empty()||value<mi.top())
            mi.push(value);
        else
            mi.push(mi.top());
    }
    void pop() {
        st.pop();
        mi.pop();
    }
    int top() {
        return st.top();
    }
    int min() {
        return mi.top();
    }
};
```

## 栈的压入和弹出序列

```
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
```

```
如果下一个唐楚的数字刚好是栈顶数字，那么直接弹出；如果下一个弹出的数字不在栈顶，则把压栈序列中还没有入栈的数字压入辅助栈，知道把下一个需要弹出的数字压入栈顶为止；如果所有数字都压入栈，然后仍然没有找到下一个弹出的数字，那么该序列不可能是一个弹出序列。
```

```cpp
bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        bool res = false;
        stack<int> st;
        int i=0,j=0;
        if(pushV.size()!=popV.size())
            return false;
        if(!pushV.empty()&&!popV.empty()){
            while(j<popV.size()){
                if(!st.empty() && st.top()==popV[j]){
                    st.pop();
                    j++;
                }else{
                    if(i==pushV.size())
                        break;
                    while(st.empty()||st.top()!=popV[j]&&i<pushV.size()){
                        st.push(pushV[i]);
                        i++;
                    }
                }
            }
            if(st.empty()&&j==popV.size())
                res=true;
        }
        return res;
}
```



## 二进制中1的个数

```
输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。
```

```
把一个整数减去1，再和原整数做与运算，会把该整数最右边的1变成0。那么一个整数的二进制中有多少个1就可以进行多少次这样的操作
```

```cpp
int  NumberOf1(int n) {
         int res = 0;
         while(n){
             res++;
             n = n & (n-1);
         }
         return res;
}
```

## 数值的整数次方

```
给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
不得使用库函数，同时需要考虑大数问题。
```

```
预处理：求pow(a, n)，如果n为负数怎么解决？
n为偶数，a^n = a^(n/2)*a^(n/2)
n为奇数，a^n = a^((n-1)/2)*a^((n-1)/2)*a
```

```cpp
double Power(double base, int exponent) {
        if(base==0.0 && exponent<0) //对0求倒数的情况
            return 0.0;
        int absExp = abs(exponent);
        double res = PowerExponent(base,absExp);
        if(exponent<0)
            res = 1.0/res;
        return res;
    }
    double PowerExponent(double base,int absExp){
        if(absExp==0)
            return 1.0;
        if(absExp==1)
            return base;
        double res = PowerExponent(base,absExp/2);
        res *= res;
        if(absExp & 0x1)  //奇数
            res *= base;
        return res;
}
```

## 打印从1到最大的N位数

```
输入数字n，按照顺序打印出从1到最大的n位十进制数，比如数组3，则打印1 2 3 一直到最大的3位数999
```

```
陷阱：当n很大时，需要考虑大数问题，需要使用字符串模型数字加法
```

```cpp
void Print1ToMaxOfNDigits(int n){
    if(n<=0)
        return;
    string number(n,'0');
    while(!Increment(number)){
        PrintNumber(number);
    }
}
bool Increment(string &number){
    bool isOverflow = false;
    int nTakeOwver = 0;
    int nLength = number.length();
    for(int i=nLength-1;i>=0;i--){
        int nSum = number[i]-'0'+nTakeOver;
        if(i==nLength-1)
            nSum += 1;
        if(nSum >= 10){
            if(i==0)
                isOverflow = true;
            else{
                nSum -= 10;
                nTakeOver = 1;
                number[i] = '0'+nSum;
            }
        }else{
            number[i] = '0' + nSum;
            break;
        }
    }
    return isOverflow;
}
void PrintNumber(string number){
    bool isBegining0 = true;
    int nLength = number.length();
    for(int i=0;i<nLength;i++){
        if(isBegining0&&number[i]!='0')
            isBegining0=false;
        if(!isBegining0)
            cout<<number[i];
    }
    cout<<"\t";
}
```

## 删除链表节点

```
给定单向链表的头指针和一个节点指针，定义一个函数再O(1)时间内删除该节点
```

```
把下一个节点的内容复制到需要删除的节点覆盖原来的内容，再把下一个节点删除
如果要删除的节点位于链表的尾部，仍然需要从链表的头结点开始，顺序遍历得到该节点的前序节点，并完成删除操作
如果链表中只有一个节点，而我们又要删除链表的头结点，那么再删除节点之后还需要把聊表的头结点设置为nullptr
```

```cpp
void DeleteNode(ListNode **head,ListNode *deleted){
    if(head==nullptr||deleted==nullptr)
        return;
    //要删除的节点不是尾节点
    if(deleted->next!=nullptr){
        ListNode *pnext = deleted->next;
        deleted->value = pnext->value;
        deleted->next = pnext->next;
        delete pnext;
        pnext = nullptr;
    }else if(*head==deleted){  //只有一个节点，删除头结点
        delete deleted;
        deleted = nullptr;
        *head = nullptr;
    }else{  //链表中有多个节点。删除尾节点
        ListNode *p = *head;
        while(p->next != deleted){
            p = p->next;
        }
        p->next = nullptr;
        delete deleted;
        deleted = nullptr;
    }
}
```

## 删除链表中重复节点

```
在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
```

```cpp
ListNode* deleteDuplication(ListNode* pHead) {
        if (pHead == nullptr || pHead->next == nullptr) {
            return pHead;
        }
 
        ListNode* dummy = new ListNode(-1);
        dummy->next = pHead;
        ListNode* pre = dummy;
        ListNode* cur = nullptr;
        ListNode* temp = nullptr;
         
        while (pre->next != nullptr) {
            cur = pre->next;
            if (cur->next != nullptr && cur->next->val == cur->val) {
                int target = cur->val;
                while (cur != nullptr && cur->val == target) {
                    temp = cur;
                    cur = cur->next;
                    delete temp;
                }
                pre->next = cur;
            } else {
                pre = pre->next;
            }
        }
 
        return dummy->next;
}
```

## 表示数值的字符串

```
请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。
```

```
数值可以表示为 A[.[B]]e|E[C]或.B[e|EC]
其中A 和C 可以带有正负号，B不能带有符号
```

```cpp
bool isNumeric(string str) {
        // write code here
        if(str.length()==0)
            return false;
        int index=0;
        bool numeric = scanInterger(str,index);
        //如果出现'.',则接下来是小数部分
        if(str[index]=='.'){
            ++index;
            //使用或的原因：
            //1. 小数可以没有整数部分；如 .123
            //2. 小数点后可以没有数字；如 233.
            //3. 小数点前后都可以有数字
            numeric = scanUnsignedInteger(str,index) || numeric;
        }
        if(str[index]=='e'||str[index]=='E'){
            ++index;
            //使用&&的原因
            //1. 当e或E前面没有数字时，整个字符串不能表示数字，如 .e1 e1
            //2. 当e或E后面没有整数时，整个字符串不能表示数字，如 12e 12e+5.4
            numeric=numeric&&scanInterger(str,index);
        }
        return numeric && (index==str.size());
}
bool scanInterger(string str,int &index){
        if(str[index]=='+'||str[index]=='-')
            ++index;
        return scanUnsignedInteger(str,index);
}
bool scanUnsignedInteger(string str,int &index){
        int begin=index;
        while(index<str.length()&&str[index]>='0'&&str[index]<='9')
            ++index;
        return index>begin;
}
```

## 反转链表

```
输入一个链表，反转链表后，输出新链表的表头。
```

```cpp
ListNode* ReverseList(ListNode* pHead) {
        ListNode *pre = nullptr;
        ListNode *cur = pHead;
        ListNode *nex = nullptr; // 这里可以指向nullptr，循环里面要重新指向
        while (cur) {
            nex = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nex;
        }
        return pre;
}
```

## 合并两个有序的链表

```
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。
```

```cpp
ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        ListNode tmp(0);
        ListNode *p = &tmp;
        p->next = nullptr;
        while(pHead1!=nullptr && pHead2!=nullptr){
            if(pHead1->val < pHead2->val){
                p->next=pHead1;
                pHead1 = pHead1->next;
            }else{
                p->next = pHead2;
                pHead2 = pHead2->next;
            }
            p = p->next;
        }
        if(pHead1!=nullptr) p->next = pHead1;
        if(pHead2!=nullptr) p->next = pHead2;
        return tmp.next;
}
```

## 树的子结构

```
输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）
```

```
第一步，再树A中查找与根节点值一样的节点
第二步，判断树A中以R为根节点的子树是不是和树B具有相同结构
```

```cpp
bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {
        //第一步，再树A中查找与根节点值一样的节点
        bool result = false;
        if(pRoot1!=nullptr&&pRoot2!=nullptr){
            if(Equal(pRoot1->val,pRoot2->val)){
                result = DoesTree1HaveTree2(pRoot1,pRoot2);
            }
            if(!result) result = HasSubtree(pRoot1->left, pRoot2);
            if(!result) result = HasSubtree(pRoot1->right, pRoot2);
        }
        return result;
}
bool DoesTree1HaveTree2(TreeNode* pRoot1, TreeNode* pRoot2){
        //第二步，判断树A中以R为根节点的子树是不是和树B具有相同结构
        if(pRoot2==nullptr) return true;
        if(pRoot1==nullptr) return false;
        if(!Equal(pRoot1->val, pRoot2->val)){
            return false;
        }
        return DoesTree1HaveTree2(pRoot1->left, pRoot2->left) && DoesTree1HaveTree2(pRoot1->right, pRoot2->right);
}
bool Equal(double num1,double num2){
        if(abs(num1-num2)<1e-6)
            return true;
        else
            return false;
}
```

## 二叉树的镜像

```
操作给定的二叉树，将其变换为源二叉树的镜像。
```

```
先序遍历二叉树，如果遍历到的节点有子节点，交换它的两个子节点
```

```cpp
TreeNode* Mirror(TreeNode* pRoot) {
        // write code here
        dfs(pRoot);
        return pRoot;
}
void dfs(TreeNode *root){
        if(root == nullptr) return;
        swap(root->left, root->right);
        dfs(root->left);
        dfs(root->right);
}
```

## 对称的二叉树

```
请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。
```

```
前序遍历：根-左-右
对称前序遍历：根-右-左
当树对称时，前序遍历和对称前序遍历的结果相同
```

```cpp
bool isSymmetrical(TreeNode* pRoot) {
        return isSymmetrical(pRoot,pRoot);
}
bool isSymmetrical(TreeNode *pRoot1,TreeNode *pRoot2){
        if(pRoot1==nullptr && pRoot2==nullptr)
            return true;
        if(pRoot1==nullptr || pRoot2==nullptr)
            return false;
        return pRoot1->val == pRoot2->val &&
            isSymmetrical(pRoot1->left,pRoot2->right) &&
            isSymmetrical(pRoot1->right,pRoot2->left);
}
```

## 顺时针打印矩阵

```
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 
1 2 3 4 
5 6 7 8 
9 10 11 12 
13 14 15 16 
则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.
```

```cpp
vector<int> printMatrix(vector<vector<int> > matrix) {
        vector<int> res;
        if(matrix.empty()) return res;
        int left=0,top=0;
        int right = matrix[0].size()-1,bottom=matrix.size()-1;
        while(left<=right && top<=bottom){
            //上
            for(int i=left;i<=right;i++) res.push_back(matrix[top][i]);
            top ++;
            //右
            for(int i=top;i<=bottom;i++) res.push_back(matrix[i][right]);
            right--;
            //下
            for(int i=right;i>=left&& top-1!=bottom;i--) res.push_back(matrix[bottom][i]);  //只有一行时不用走回来，前面已经走了
            bottom--;
            //左
            for(int i=bottom;i>=top&&left-1!=right;i--) res.push_back(matrix[i][left]); //只有一列时不用走回来，前面已经走了
            left++;   
        }
        return res;
}
```

## 从上到下打印二叉树

```
从上往下打印出二叉树的每个节点，同层节点从左至右打印。
```

```cpp
vector<int> PrintFromTopToBottom(TreeNode* root) {
        vector<int> res;
        queue<TreeNode *> mq;
        if(root!=nullptr){
            mq.push(root);
        }
        while(!mq.empty()){
            TreeNode *node = mq.front();
            if(node->left!=nullptr) mq.push(node->left);
            if(node->right!=nullptr) mq.push(node->right);
            res.push_back(node->val);
            mq.pop();
        }
        return res;
}
```

## 分行从上到下打印二叉树

```
从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。
```

```cpp
vector<vector<int> > Print(TreeNode* pRoot) {
            vector<vector<int>> res;
            if(pRoot==nullptr)
                return res;
            queue<TreeNode *> mq;
            mq.push(pRoot);
            while(!mq.empty()){
                int size = mq.size();
                vector<int> lay;
                for(int i=0;i<size;i++){
                    lay.push_back(mq.front()->val);
                    if(mq.front()->left!=nullptr) mq.push(mq.front()->left);
                    if(mq.front()->right!=nullptr) mq.push(mq.front()->right);
                    mq.pop();
                }
                res.push_back(lay);
                lay.clear();
            }
            return res;
}
```

## 之字形打印二叉树

```
请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。
```

```
按之字形顺序打印二叉树需要两个栈。我们再打印某一层的节点时，把下一层的子节点保存到相应的栈里。
如果当前打印的是奇数层，则先保存左子节点再保存右子节点到第一个栈里
如果当前打印的是偶数层，则先保存右子节点再保存左子节点到第二个栈里
```

```cpp
vector<vector<int> > Print(TreeNode* pRoot) {
        vector<vector<int>> res;
        if(pRoot==nullptr)
            return res;
        stack<TreeNode *> levels[2];
        int current = 0;
        int next = 1;
        vector<int> vec;
        levels[current].push(pRoot);
        while(!levels[0].empty()||!levels[1].empty()){
            TreeNode *pNode = levels[current].top();
            levels[current].pop();
            vec.push_back(pNode->val);
            if(current==0){
                if(pNode->left!=nullptr) levels[next].push(pNode->left);
                if(pNode->right!=nullptr) levels[next].push(pNode->right);
            }else{
                if(pNode->right!=nullptr) levels[next].push(pNode->right);
                if(pNode->left!=nullptr) levels[next].push(pNode->left);
            }
            if(levels[current].empty()){
                res.push_back(vec);
                vec.clear();
                swap(current, next);
            }
        }
        return res;
}
```

## 二叉搜索树的后续遍历序列

```
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回true,否则返回false。假设输入的数组的任意两个数字都互不相同。
```

```
在后续遍历得到的序列中，最后一个数字是树的根节点的值。数组中前面的数字可以分为两部分：第一部分是左子树，它们都比树的根节点的值小；第二部分是右子树，它们的值都比根节点的值大。
使用递归的方法确定与数组每一部分对应的子树结构
```

```cpp
bool VerifySquenceOfBST(vector<int> sequence) {
        if (sequence.size() == 0) return false;
        int lens = sequence.size();
        int root = sequence[lens-1];
        //在二叉搜索树中的左子树节点的值小于根节点的值
        int index = 0;
        while (root > sequence[index]) {
            index++;
        }
        //在二叉搜索树中的右子树节点的值大于根节点的值
        for (int j = index; j < lens - 1; j++) {
            if (sequence[j] < root) {
                return false;
            }
        }
        vector<int> _Left (sequence.begin(), sequence.begin()+index);
        vector<int> _Right (sequence.begin()+index, sequence.end()-1);
        //判断左子树是不是二叉搜索树
        bool left = _Left.size() > 0 ? VerifySquenceOfBST(_Left) : true;
        //判断右子树是不是二叉搜索树
        bool right = _Right.size() > 0 ? VerifySquenceOfBST(_Right) : true;
        return left && right;
}
```

## 复杂链表的复制

```
请实现一个函数实现复杂链表的复制。在复杂链表中，每个节点除了有一个m_pNext指针指向下一个节点，还有一个m_pSlibing指针指向量表中的任意节点或者nullptr
```

```
第一步：根据原始链表的每个节点N创建对应的N',把N'链接再N后面
第二步：设置复制出来的节点的m_pSibling,N的m_pSibling指向节点S，则N‘的m_pSibling指向S'
第三步：把长链表拆分成两个链表，把奇数位置的节点用m_pNext链接起来就是原始链表，把偶数位置的节点用m_pNext链接起来就是复制出来的链表
```

```cpp
RandomListNode* Clone(RandomListNode* pHead) {
        if(pHead==nullptr)
            return nullptr;
        RandomListNode *head = pHead;
        //第一步：根据原始链表的每个节点N创建对应的N',把N'链接再N后面
        while(head!=nullptr){
            RandomListNode *clone = new RandomListNode(head->label);
            clone->next = head->next;
            head->next = clone;
            head = clone->next;
        }
        //第二步：设置复制出来的节点的m_pSibling,N的m_pSibling指向节点S，则N‘的m_pSibling指向S'
        RandomListNode *head1 = pHead;
        RandomListNode *clone1;
        while(head1){
            clone1 = head1->next;
            if(head1->random != nullptr)
                clone1->random = head1->random->next;
            else
                clone1->random = nullptr;
            head1 = clone1->next;
        }
        //第三步：把长链表拆分成两个链表，把奇数位置的节点用m_pNext链接起来就是原始链表，把偶数位置的节点用m_pNext链接起来就是复制出来的链表
        RandomListNode *head2 = pHead;
        RandomListNode *clone2;
        RandomListNode *cloned = pHead->next;
        while(head2){
            clone2 = head2->next;
            head2->next = clone2->next;
            head2 = head2->next;
            if(head2!=nullptr)
                clone2->next = head2->next;
        }
        return cloned;
}
```

## 二叉搜索树与双向链表

```
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。
```

```
二叉搜索树的性质是：左节点 < 当前节点 < 右节点。转换后的双向链表是有序的，这里采用中序递归遍历保证有序性。
```

```cpp
TreeNode* Convert(TreeNode* pRootOfTree) {
        if(pRootOfTree == nullptr) return nullptr;
        // 双向链表尾节点
        TreeNode* list_last = nullptr;
        // 递归建立双向链表
        ConvertNode(pRootOfTree,list_last);
        // 查找双向链表首节点
        while(list_last->left != nullptr)
        {
            list_last = list_last->left;
        }
  
        // 返回双向链表的首节点
        return list_last;
}
// 对BST中序遍历，得到有序序列；调整序列元素的指针，将有序序列调整为双向链表
void ConvertNode(TreeNode* cur,TreeNode *&list_last) // 注意形参
{
        // 边界条件(递归出口)
        if(cur==nullptr) return ;
  
        // 遍历左子树
        if(cur->left != nullptr) ConvertNode(cur->left,list_last);
  
        // 建立双向链接
        cur->left = list_last;                           // 单侧链接
        if(list_last != nullptr) list_last->right = cur; // 单侧链接
        list_last = cur;
  
        //遍历右子树
        if(cur->right != nullptr) ConvertNode(cur->right,list_last);
}
```

## 序列化二叉树

```
请实现两个函数，分别用来序列化和反序列化二叉树
```

```
根据前序遍历序列化和反序列化树
```

```cpp
class Solution {
public:
    string s;
    int j =0;
    void Serial(TreeNode *root)
    {
        if(root==NULL)
        {
            s+="#!";
            return;
        }
        s+= to_string(root->val);
        s+='!';
        Serial(root->left);
        Serial(root->right);
    }
     
     
    TreeNode* Deserial(string s)
    {
        if (s.size()==0) return NULL;
        if (s[j] == '!')
        {
            j++;
            if(j>=s.size())
            {
                return NULL;
            }
        }
        if (s[j]=='#')
        {
            j++;
            return NULL;
        }
        int num = 0;
        while(s[j]>='0' && s[j]<='9')
        {
            num = num*10 + s[j++]-'0';
        }
        TreeNode *root = new TreeNode(num);
        root->left = Deserial(s);
        root->right = Deserial(s);
        return root;
    }
     
    char* Serialize(TreeNode *root) {   
        Serial(root);
        return (char*)s.data();
         
    }
    TreeNode* Deserialize(char *str) {
        s = str;
        return Deserial(s);
    }
};
```

## 数组中出现次数超过一半的数字

```
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。
```

```
解法一：快排思路，时间复杂度为O(n)
先再数组中随机选择一个数字，然后调整数组数组的顺序，使得比选中的数字小的数字都排在它的左边，比选中的数字大的数字都排在它的右边，如果选中的数字的下标刚好是n/2,那么这个数字就是数组的中位数；如果下标大于n/2，那么中位数位于它的左边，我们可以接着再它的左边部分的数组中查找；如果它的下标小于n/2,那么中位数应该位于它的右边，我们可以接着在它的右边部分的数组中查找。
解法二：根据数组特点找出时间复杂度为O(n)的算法
数组中有一个数组出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现的次数的和还要多。
因此我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，另一个是次数；当遍历到下一个数字的时候，如果下一个数字和我们之前保存的数字相同，则次数加1；如果下一个数字和我们之前保存的数字不同，则次数减1；如果次数为0，呢么我们需要保存下一个数字，并把次数设为1。
由于我们要找的数字出现的次数比其他所有数字出现的次数之和还要多，那么要找的数字肯定是最后一次把次数设置为1时对应的数字。
```

```cpp
int MoreThanHalfNum_Solution(vector<int> numbers) {
        if(numbers.size()==0) 
            return 0;
        int result = numbers[0];
        int times = 1;
        for(int i=1;i<numbers.size();i++){
            if(times==0){
                result = numbers[i];
                times = 1;
            }else if(numbers[i] == result)
                times++;
            else
                times--;
        }
        //check the result
        int count = 0;
        for(int i=0;i<numbers.size();i++){
            if(numbers[i] == result)
                count++;
        }
        if(count*2<=numbers.size())
            return 0;
        return result;
}
```

## 最小的K个数

```
给定一个数组，找出其中最小的K个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。如果K>数组的长度，那么返回一个空的数组
```

```
解法一：快排思路，时间复杂度为O(n)  (修改了原有数据，且要求所有数据都加载到内存中)
先再数组中随机选择一个数字，然后调整数组数组的顺序，使得比选中的数字小的数字都排在它的左边，比选中的数字大的数字都排在它的右边，如果选中的数字的下标刚好是K-1,那么左边数据即为结果；如果下标大于K-1，对左边部分的数组进行快排；如果它的下标小于K-1,对右边部分的数组进行快排。
```

```
解法二：时间复杂度为O(nlogk)  （没有修改输入数据，适用于海量数据）
创建一个容量为k的最大堆，如果堆未满，直接插入，如果堆满，比较插入元素和堆顶元素的大小，比堆顶元素小，则删除堆顶元素，插入新元素，否则不做任何操作；
返回最大堆中元素
```

```cpp
vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        vector<int> result;
        if(input.empty()||k<=0||input.size()<k)
            return result;
        priority_queue<int> bheap;
        for(int i=0;i<input.size();i++){
            if(bheap.size()<k){
                bheap.push(input[i]);
            }else{
                if(input[i]<bheap.top()){
                    bheap.pop();
                    bheap.push(input[i]);
                }
            }
        }
        while(!bheap.empty()){
            result.push_back(bheap.top());
            bheap.pop();
        }
        return result;
}
```

## 数据流中的中位数

```
有一个源源不断的吐出整数的数据流，假设你有足够的空间来保存吐出的数。请设计一个名叫MedianHolder的结构，MedianHolder可以随时取得之前吐出所有数的中位数。
[要求]
1. 如果MedianHolder已经保存了吐出的N个数，那么将一个新数加入到MedianHolder的过程，其时间复杂度是O(logN)。
2. 取得已经吐出的N个数整体的中位数的过程，时间复杂度为O(1)

每行有一个整数opt表示操作类型
若opt=1，则接下来有一个整数N表示将N加入到结构中。
若opt=2，则表示询问当前所有数的中位数
输入
[[1,5],[2],[1,3],[2],[1,6],[2],[1,7],[2]]
输出
[5,4,5,5.5]
```

```
创建一个最大堆，存放较小的数据
创建一个最小堆，存放较大的数据
保证大小堆中的元素个数差不超过1,如果是奇数，取size多1的那一边
```

```cpp
class Solution {
public:
    /**
     * the medians
     * @param operations int整型vector<vector<>> ops
     * @return double浮点型vector
     */
    // 保证大小堆中的元素个数差不超过1,如果是奇数，取size多1的那一边
    priority_queue<int, vector<int>, less<int>> maxHeap;
    priority_queue<int,vector<int>,greater<int>> minHeap;
    vector<double> flowmedian(vector<vector<int> >& operations) {
        // write code here
        vector<double> res;
        for(auto vec:operations){
            if(vec[0]==1) 
                addNum(vec[1]);
            else
                res.push_back(getMedian());
        }
        return res;
    }
    
    void addNum(int num){
        //首先都放在大顶堆
        maxHeap.push(num);
        if(maxHeap.size()>minHeap.size()+1){
            minHeap.push(maxHeap.top());
            maxHeap.pop();
        }
        //保证大顶堆的元素都<小顶堆的元素
        if(!maxHeap.empty()&&!minHeap.empty()&&maxHeap.top()>minHeap.top()){
            maxHeap.push(minHeap.top());
            minHeap.pop();
            minHeap.push(maxHeap.top());
            maxHeap.pop();
        }
    }
    
    double getMedian(){
        if(maxHeap.empty()&&minHeap.empty()) 
            return -1;
        if(maxHeap.size()==minHeap.size())
            return (maxHeap.top()+minHeap.top())*0.5;
        return maxHeap.size()>minHeap.size()?maxHeap.top():minHeap.top();
        
    }
};
```

## 1~n整数中1出现的次数

```
输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数
例如，1~13中包含1的数字有1、10、11、12、13因此共出现6次
```

```
统计某个位置上 1出现的次数。如34，1在十位上出现的次数是10次（10到19），1在个位上出现的次数是4次（1，11，21，31），因此34中1出现了14次。
对于整数n，将这个整数分为三部分：当前位数字cur，更高位数字high，更低位数字low，如：对于n=21034，当位数是十位时，cur=3，high=210，low=4。
我们从个位到最高位 依次计算每个位置出现1的次数：
在计算时，会出现三种情况
1）当前位的数字等于0时，例如n=21034，在百位上的数字cur=0，百位上是1的情况有：00100-00199，01100-01199，……，20100-20199。一共有21*100种情况，即high*100;
2）当前位的数字等于1时，例如n=21034，在千位上的数字cur=1，千位上是1的情况有：01000-01999，11000-11999，21000-21034。一共有2*1000+（34+1）种情况，即high*1000+(low+1)。
3）当前位的数字大于1时，例如n=21034，在十位上的数字cur=3，十位上是1的情况有：00010-00019，……，21010-21019。一共有(210+1)*10种情况，即(high+1)*10。
```

```cpp
int NumberOf1Between1AndN_Solution(int n) {
        int count=0;
        for(int i=1;i<=n;i*=10){  //i代表位数
            int high=n/(i*10); //更高位数字
            int low=(n%i);  //更低位数字
            int cur=(n/i)%10;  //当前位数字
            if(cur==0){
                count+=high*i;
            }else if(cur==1){
                count+=high*i+(low+1);
            }else{
                count+=(high+1)*i;
            }
        }
        return count;
}
```

## 数字序列中某一位的数字

```
数字以0123456789101112131415...的格式序列化到一个字符序列中。在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。请写一个函数，求任意第n位对应的数字。
```

```cpp
int digitAtIndex(int index){
    if(index<0)
        return -1;
    int digits = 1;  //数字的位数
    while(true){
        int numbers = countOfIntegers(digits);  //计算相应位数数字的总个数
        if(index<numbers*digits)
            return digitAtIndex(index,digits);
        index -= digits*numbers;
        digits++;
    }
    return -1;
}
int countOfIntegers(int digits){
    if(digits==1)
        return 10;
    int count = (int)std::pow(10,digits-1);
    return 9*count;
}
int digitAtIndex(int index,int digits){
    int number = beginNumber(digits)+index/digits;
    int indexFromRight = digits - index%digits;
    for(int i=1;i<indexFromRight;++i)
        number/=10;
    return number%10;
}
int beginNumber(int digits){
    if(digits == 1)
        return 0;
    return (int)std::pow(10,digits-1);
}
```

## 把数组排成最小的数

```
输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。
```

```
有两个字符串a,b，
如果a + b < b + a, 显然我们希望a排在b的前面，因为a排在前面可以使结果更小。于是我们就自定义排序规则，使得vector中字符串都满足如上规则，那么最后的结果肯定是最小的。
```

```cpp
string PrintMinNumber(vector<int> numbers) {
        vector<string> str;
        for (int val : numbers) str.push_back(to_string(val));
        sort(str.begin(), str.end(), [](string a, string b) {
            return a + b < b + a;
        });
        string ret = "";
        for (string s : str) ret += s;
        return ret;
}
```

## 丑数

```
把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。
```

```cpp
int GetUglyNumber_Solution(int index) {
        if(index <= 0)return 0;
        int p2=0,p3=0,p5=0;//初始化三个指向三个潜在成为最小丑数的位置
        int *result = new int[index];
        result[0] = 1;//
        for(int i=1; i < index; i++){
            result[i] = min(result[p2]*2, min(result[p3]*3, result[p5]*5));
            if(result[i] == result[p2]*2)p2++;//为了防止重复需要三个if都能够走到
            if(result[i] == result[p3]*3)p3++;//为了防止重复需要三个if都能够走到
            if(result[i] == result[p5]*5)p5++;//为了防止重复需要三个if都能够走到
 
 
        }
        return result[index-1];
}
```

## 第一个只出现一次的字符

```
在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）
如输入“abaccdeff”,则输出1
```

```cpp
int FirstNotRepeatingChar(string str) {
        unordered_map<char, int> mp;
        for (const char ch : str) {
            ++mp[ch];
        }    
        for (int i=0; i<str.length(); ++i) {
            if (mp[str[i]] == 1) return i;
        }
        return -1;
}
```

## 字符流中第一个只出现一次的字符

```
请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。
```

```cpp
#include<vector>

class Solution
{
    int index;
    int occurrence[256];
public:
    Solution():index(0){
        for(int i=0;i<256;i++)
            occurrence[i] = -1;
    }
  //Insert one char from stringstream
    void Insert(char ch) {
         if(occurrence[ch]==-1)
             occurrence[ch] = index;
        else if(occurrence[ch]>=0)
             occurrence[ch] = -2;
        index ++;
    }
  //return the first appearence once char in current stringstream
    char FirstAppearingOnce() {
        char ch = '#';
        int minIndex = numeric_limits<int>::max();
        for(int i=0;i<256;i++){
            if(occurrence[i]>=0 && occurrence[i]<minIndex){
                ch = (char)i;
                minIndex = occurrence[i];
            }
        }
        return ch;
    }

};
```

## 数组中的逆序对

```
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
```

```
归并排序的过程就是，递归划分整个区间为基本相等的左右区间，直到左右区间各只有一个数字，然后就合并两个有序区间。
先把数组分隔成子数组，统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中还需要对数组进行排序。
```

```cpp
class Solution {
public:
    int InversePairs(vector<int> data) {
        int length=data.size();
        if(length<=0)
            return 0;
       //vector<int> copy=new vector<int>[length];
       vector<int> copy;
       for(int i=0;i<length;i++)
           copy.push_back(data[i]);
       long long count=InversePairsCore(data,copy,0,length-1);
       //delete[]copy;
       return count%1000000007;
    }
    long long InversePairsCore(vector<int> &data,vector<int> &copy,int start,int end)
    {
       if(start==end)
          {
            copy[start]=data[start];
            return 0;
          }
       int length=(end-start)/2;
       long long left=InversePairsCore(copy,data,start,start+length);
       long long right=InversePairsCore(copy,data,start+length+1,end); 
        
       int i=start+length;
       int j=end;
       int indexcopy=end;
       long long count=0;
       while(i>=start&&j>=start+length+1)
          {
             if(data[i]>data[j])
                {
                  copy[indexcopy--]=data[i--];
                  count=count+j-start-length;          //count=count+j-(start+length+1)+1;
                }
             else
                {
                  copy[indexcopy--]=data[j--];
                }          
          }
       for(;i>=start;i--)
           copy[indexcopy--]=data[i];
       for(;j>=start+length+1;j--)
           copy[indexcopy--]=data[j];       
       return left+right+count;
    }
};
```

## 二叉搜索树的第K大节点

```
给定一棵二叉搜索树，请找出其中的第k大的结点
```

```
只需要用中序遍历算法遍历一颗二叉树，就很容易找到它的第k大节点
```

```cpp
int index = 0; //计数器
    TreeNode* KthNode(TreeNode* pRoot, int k) {
        if(pRoot != nullptr){ //中序遍历寻找第k个
            TreeNode *node = KthNode(pRoot->left,k);
            if(node != nullptr)
                return node;
            index ++;
            if(index == k)
                return pRoot;
            node = KthNode(pRoot->right,k);
            if(node != nullptr)
                return node;
        }
        return nullptr;
}
```

## 二叉树的深度

```
输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。
```

```
二叉树的深度=max(左子树深度，右子树深度)+1
```

```cpp
int TreeDepth(TreeNode* pRoot) {
        if(pRoot==nullptr)
            return 0;
        int left = TreeDepth(pRoot->left);
        int right = TreeDepth(pRoot->right);
        
        return max(left,right)+1;
}
```

## 平衡二叉树

```
输入一棵二叉树，判断该二叉树是否是平衡二叉树。
在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树
平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
```

```
使用后序遍历的方式遍历二叉树的每个节点，那么再遍历到一个节点之前就已经遍历了它的左、右子树，根据左、右子树的深度判断它是不是平衡的，并得到当前节点的深度，当最后遍历到树的根节点时，也就判断了整棵树是不是平衡二叉树。
```

```cpp
bool IsBalanced_Solution(TreeNode* pRoot) {
        int depth = 0;
        return IsBalanced(pRoot,&depth);
}
    
bool IsBalanced(TreeNode* pRoot,int *pDepth){
        if(pRoot==nullptr){
            *pDepth = 0;
            return true;
        }
        int left,right;
        if(IsBalanced(pRoot->left, &left) && IsBalanced(pRoot->right, &right)){
            int diff = left - right;
            if(abs(diff)<=1){
                *pDepth = 1+ max(left,right);
                return true;
            }
        }
        return false;
}
```

## 数组中只出现一次的两个数字

```
一个整型数组里除了两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度为O(n),空间复杂度是O(1)
```

```
性质：任何一个数字异或它自己都等于0
思路：把原有数组分成两个子数组，使得每个子数组包含一个只出现一次的数字，而其他数字都成对出现两次。每次子数组从头到尾一次异或，那么最终的结果即为要只出现一次的两个数字。
步骤：
1. 从头到尾一次一会数组中的每个数字，那么最终结果就是两个只出现一次的数字的异或结果，因为其他数字都出现了两次，在异或中全部抵消了
2. 在结果数字中找到第一个为1的位的位置，记为第n位。
3. 以第n位是不是1为标准，把原数组中的数字分为两个子数组，第一个子数组中每个数字的第n位都是1，而第二个数组中每个数字的第n位都是0.（出现了两次的数字肯定被分配到同一个数组，因为两个相同的数字任意一位都是相同的）
4. 对两个数组从头到尾求异或，结果即为两个只出现一次的数字
```

```cpp
vector<int> FindNumsAppearOnce(vector<int>& array) {
        // write code here
        vector<int> res;
        if(array.size()<2)
            return res;
        int resultExclusiveOR = 0;
        for(int i=0;i<array.size();i++)
            resultExclusiveOR ^= array[i];
        int t = 1;//找出异或和中哪一位是1
        while((resultExclusiveOR&t)==0)
        {
            t=t<<1;
        }
        int num1=0,num2=0;
        for(int j=0;j<array.size();j++){
            if(t&array[j])
                num1 ^= array[j];
            else
                num2 ^= array[j];
        }
        res.push_back(min(num1,num2));
        res.push_back(max(num1,num2));
        return res;
}
```

## 数组中唯一只出现一次的数字

```
在一个数组中除了一个数字只出现一次之外，其他数字都出现了三次，请找出那个只出现一次的数字。
```

```
把数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除，那么那个只出现一次的数字二进制表示中对应的那一位为0，否则为1
```

```cpp
int foundOnceNumber(vector<int>& arr) {
        // write code here
        int bitSum[32] = {0};
        for(int i=0;i<arr.size();i++){
            int bitMask = 1;
            for(int j=31;j>=0;j--){
                int bit = arr[i]&bitMask;
                if(bit!=0)
                    bitSum[j]+=1;
                bitMask=bitMask<<1;
            }
        }
        int result = 0;
        for(int i=0;i<32;i++){
            result = result <<1;
            result += bitSum[i]%3;
        }
        return result;
}
```

## 翻转单词顺序

```
输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串“I am a student.”，则输出“student. a am I”。
```

```
第一步翻转句子中所有的字符。
第二步再翻转每个单词中字符的顺序。
```

```cpp
string ReverseSentence(string str) {
        if(str.empty())
            return str;
        Reverse(str,0,str.length()-1);  //转句子中所有的字符
        int start=0,end=0;
        while(start < str.length()){
            if(str[start]==' '){
                start++;
                end++;
            }else if(end==str.length()||str[end]==' '){
                Reverse(str, start, end-1);
                end++;
                start=end;
            }else{
                end++;
            }
        }
        return str;
}
void Reverse(string &str,int begin,int end){
        while(begin<end){
            swap(str[begin],str[end]);
            begin++;
            end--;
        }
}
```

## 左旋转字符串

```
字符串的左旋转操作是把字符串你前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"
```

```
把字符串分为两个部分，分别翻转这两部分，再翻转整个字符串
```

```cpp
string LeftRotateString(string str, int n) {
        if(!str.empty()){
            int nLength = str.length();
            if(nLength>0&&n>0&&n<nLength){
                Reverse(str, 0, n-1);
                Reverse(str, n, nLength-1);
                Reverse(str, 0, nLength-1);
            }
        }
        return str;
}
void Reverse(string &str,int begin,int end){
        while(begin<end){
            swap(str[begin],str[end]);
            begin++;
            end--;
        }
}
```

## 队列的最大值

```
给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}
窗口大于数组长度的时候，返回空
```

```cpp
vector<int> maxInWindows(const vector<int>& num, unsigned int size) {
        vector<int> ret;
        if (num.size() == 0 || size < 1 || num.size() < size) return ret;
        int n = num.size();
           deque<int> dq;
           for (int i = 0; i < n; ++i) {
               while (!dq.empty() && num[dq.back()] < num[i]) {
                   dq.pop_back();
               }
               dq.push_back(i);
               // 判断队列的头部的下标是否过期
               if (dq.front() + size <= i) {
                   dq.pop_front();
                }
                // 判断是否形成了窗口
               if (i + 1 >= size) {
                   ret.push_back(num[dq.front()]);
               }
           }
           return ret;
}
```

## 不使用加减乘除做加法

```
写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。
```

```
计算a和b的无进位和，和进位
如果进位不为0，则说明a+b的结果等于无进位和+进位，此时，把无进位和作为a，进位作为b，继续计算
如果进位等于0， 说明此时a+b的结果就等于无进位和，返回无进位和即可。
```

```cpp
int Add(int num1, int num2) {
        while (num2 != 0) {
            // 负数左移会在低位补1，所以转化为无符号整数
            int c = ((unsigned int)(num1 & num2)) << 1;
            num1 ^= num2;
            num2 = c;
        }
        return num1;
}
```



