# 模板编程

## 1. 语法

```
/**
* template -- 声明创建模板
* typename -- 表面其后面的符号是一种数据类型，可以用class代替
* T -- 通用的数据类型，名称可以替换，通常为大写字母
**/
template<typename T> 或 
template<class T>
```

## 2. 函数模板

### 2.1 函数模板示例

```cpp
#include<iostream>
using namespace std;

//两个整型交换
void swapInt(int& a, int& b)
{
	int temp = a;
	a = b;
	b = temp;
}

//交换两个浮点数据
void swapDouble(double& a, double& b)
{
	double temp = a;
	a = b;
	b = temp;
}

//利用模板实现交换函数
template<typename T>//声明一个模板 告诉编译器后面代码中紧跟着的T不要报错，T是一个通用数据类型
void mySwap(T& a, T& b)
{
	T temp = a;
	a = b;
	b = temp;
}

void test01()
{
	int a = 10;
	int b = 20;
	//swapInt(a, b);
	/*利用模板交换
	* 两种方式使用函数模板
	* 1、自动类型推导
	*/
	//mySwap(a, b);
	cout << "a = " << a << endl;//20
	cout << "b = " << b << endl;//10
	//2、显示指定类型
	mySwap<int>(a, b);
	cout << "a = " << a << endl;
	cout << "b = " << b << endl;

	double c = 1.1;
	double d = 2.2;
	//swapDouble(c, d);
	mySwap<double>(c, d);
	cout << "c = " << c << endl;//2.2
	cout << "d = " << d << endl;//1.1
}

int main()
{
	test01();
	system("pause");
	return 0;
}
```

### 2.2 函数模板注意事项

1. 自动类型推导，必须推导出一致的数据类型 T，才可以使用
2. 模板必须要确定出 T 的数据类型，才可以使用

```cpp
#include<iostream>
using namespace std;
//利用模板实现通用的交换函数
template<typename T>
void mySwap(T& a, T& b)
{
	T temp = a;
	a = b;
	b = temp;
}
//1、自动类型推导，必须推导出一致的数据类型 T，才可以使用
void test01()
{
	int a = 10;
	int b = 20;
	char c = 'c';
	
	mySwap(a, b);//正确，可以推导出一致的 T
	//mySwap(a, c);错误，没有与参数类型一致的 函数类型 T(推导不出一致的T类型)
}

//2、模板必须要确定出 T 的数据类型，才可以使用
template<class T>
void func()
{
	cout << "func 调用" << endl;
}
void test02()
{
	//func();错误，模板不能独立使用，必须确定出T的类型
	func<int>();//利用显示指定类型的方式 给T一个类型 才可以使用该模板
}

int main()
{
	test01();
	test02();
	system("pause");
	return 0;
}
```

### 2.3 普通函数与函数模板区别

1. 普通函数调用时可以发生自动类型转换（隐式类型转换）
2. 函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
3. 如果利用显示指定类型的方式，可以发生隐式类型转换

```cpp
#include<iostream>
using namespace std;
//普通函数
int myAdd01(int a, int b)
{
	return a + b;
}

//函数模板
template<class T>
int myAdd02(T a, T b)
{
	return a + b;
}

void test01()
{
	int a = 10;
	int b = 20;
	char c = 'c';

	cout << myAdd01(a, b) << endl;//30
	cout << myAdd01(a, c) << endl;//109=10+99  a - 97  c - 99 自动类型转换

	//自动类型推导
	myAdd02(a, b);
	cout << myAdd02(a, b) << endl;//30
	//myAdd02(a, c);报错，自动类型推倒时，不会发生隐式类型转换
	myAdd02<int>(a, c);//正确，显示指定类型，可以发生隐式类型转换
}

int main()
{
	test01();
	system("pause");
	return 0;
	//总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型 T
}
```

### 2.4 普通函数与函数模板的调用规则

1. 如果函数模板和普通函数都可以实现，优先调用 普通函数（编译器有关）
2. 可以通过 空模板参数列表 来强制调用函数模板
3. 函数模板也可以发生 函数重载
4. 如果函数模板可以产生更好的匹配 优先调用 函数模板

```cpp
#include<iostream>
using namespace std;
void myprint(int a, int b)
{
	cout << "调用的是普通函数！" << endl;
}

template<class T>
void myPrint(T a, T b)
{
	cout << "调用函数模板！" << endl;
}  

template<class T>
void myPrint(T a, T b, T c)
{
	cout << "函数模板重载！" << endl;
}

void test01()
{
	int a = 10;
	int b = 20;
	//myPrint(a, b);//1、优先调用函数模板

	//2、通过空模板参数列表 强制调用函数模板
	myPrint<>(a, b);//函数模板

	//3、函数模板 重载
	int c = 30;
	myPrint<>(a, b, c);//函数模板重载
	myPrint(a, b, c);//函数模板重载

	//4、如果函数模板可以产生更好的匹配 优先调用 函数模板
	char c1 = 'a';
	char c2 = 'b';
	myPrint(c1, c2);//调用函数模板
}
int main()
{
	test01();
	system("pause");
	return 0;
	//总结：既然提供了函数模板，最好不要提供普通函数，否则容易出现二义性
}
```

### 2.5 函数模板局限性

模板的通用性不是万能的 有些特定数据类型 需要用具体化方式做特殊实现

```cpp
#include<iostream>
using namespace std;
class Person
{
public:

	Person(string name, int age)
	{
		this->m_Name = name;
		this->m_Age = age;
	}

	string m_Name;//姓名
	int m_Age;//年龄
};

//对比两个数据是否相等函数
template<class T>
bool myCompare(T& a, T& b)
{
	if (a == b)
	{
		return true;
	}
	else
	{
		return false;
	}
}

//利用具体化的Person版本实现代码，具体化会优先调用
template<> bool myCompare(Person& p1, Person& p2)
{
	if (p1.m_Name == p2.m_Name && p1.m_Age == p2.m_Age)
	{
		return true;
	}
	else
	{
		return false;
	}
}

void test01()
{
	int a = 10;
	int b = 20;
	bool ret = myCompare(a, b);
	if (ret)
	{
		cout << "a == b" << endl;
	}
	else
	{
		cout << "a != b" << endl;
	}
}

void test02()
{
	Person p1("Tom", 10);
	Person p2("Tom", 12);

	bool ret = myCompare(p1, p2);
	if (ret)
	{
		cout << "p1 == p2" << endl;//p1==p2
	}
	else
	{
		cout << "p1 != p2" << endl;
	}
}
int main()
{
	//test01();
	test02();
	system("pause");
	return 0;
	/*总结：
	1、利用具体化的模板，可以解决自定义类型的通用化
	2、学习模板不是为了写模板，而是在STL中能够运用系统提供的模板*/
}
```

### 2.6 函数模板具现化

可以让模板函数在源文件中实现，而不用放在头文件中实现。

```cpp
template<typename T>
void foo(const T& x){
}

template<typename T>
T bar(const T& x){
    return x;
}

template void foo(const int&);
template void foo(const double&);
template char bar(const char&);
```



## 3. 类模板

建立一个通用类，类中的成员 数据类型 可以不具体指定，用一个 虚拟的类型 来代表 

### 3.1 类模板示例

```cpp
#include<iostream>
using namespace std;
template<class NameType,class AgeType>
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this->m_Name = name;
		this->m_Age = age;
	}

	void showPerson()
	{
		cout << "name = " << this->m_Name << endl;
		cout << "age = " << this->m_Age << endl;
	}

public:
	NameType m_Name;
	AgeType m_Age;
};

void test01()
{
	//指定NameType 为 string 类型，AgeType 为 int 类型
	Person<string, int> p1("孙悟空", 99);
	p1.showPerson();
}

int main()
{
	test01();
	system("pause");
	return 0;
	//总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板
}
```

### 3.2 类模板和函数模板区别
1. 类模板没有自动类型推导的使用方式
2. 类模板在模板参数列表中可以有默认参数

```cpp
#include<iostream>
using namespace std;

template<class NameType,class AgeType>//模板参数列表
//template<class NameType, class AgeType = int> //模板参数列表中可以有默认参数
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this->m_Name = name;
		this->m_Age = age;
	}

	void showPerson()
	{
		cout << "name = " << this->m_Name << endl;
		cout << "age = " << this->m_Age << endl;
	}

public:
	NameType m_Name;
	AgeType m_Age;
};

//1、类模板没有自动类型推导的使用方式
void test01()
{
	//Person p("孙悟空", 999);自动类型推导失败，类模板中，无法使用自动类型推导
	Person<string, int>p("孙悟空", 999);//类模板中只能显示指定类型
	p.showPerson();
}

//2、类模板在模板参数列表中可以有默认参数
void test02()
{
	//Person<string>p1("猪八戒", 888);参数列表中可以有默认参数 class AgeType = int
	//p1.showPerson();
}
int main()
{
	test01();
	test02();
	system("pause");
	return 0;
}
```

### 3.3 类模板中成员函数创建时机

1. 普通类中的成员函数 一开始就可以创建
2. 类模板中的成员函数 在调用时才创建 因为一开始的时候不知道数据类型

```cpp
#include<iostream>
using namespace std;

class Person1
{
public:
	void showPerson1()
	{
		cout << "Person1 show!" << endl;
	}
};

class Person2
{
public:
	void showPerson2()
	{
		cout << "Person2 show!" << endl;
	}
};

template<class T>
class MyClass 
{
public:
	T obj;//编译成功 类模板中的成员函数 在调用时才创建
	//类模板中的成员函数
	void func1()
	{
		obj.showPerson1();
	}

	void func2()
	{
		obj.showPerson2();
	}
};

void test01()
{
	MyClass<Person1>m;
	m.func1();//Person1 show!
	//m.func2();//showPerson2不是Person1的成员函数，编译出错
}

int main()
{
	test01();
	system("pause");
	return 0;
	//总结：类模板中的成员函数 不是 一开始就可以创建 而是在调用时才创建
}
```

### 3.4 类模板对象做函数参数

1. 指定传入的类型：直接显示对象的数据类型（常用）
2. 参数模板化：将对象中的参数变为模板进行传递
3. 整个类模板化：将这个对象类型 模板化进行传递

```cpp
#include<iostream>
using namespace std;
template<class T1,class T2>
class Person
{
public:

	Person(T1 name,T2 age)
	{
		this->m_Name = name;
		this->m_Age = age;
	}

	void showPerson()
	{
		cout << "姓名：" << this->m_Name << "\t年龄：" << this->m_Age << endl;
	}

	T1 m_Name;
	T2 m_Age;
};
//1、指定传入类型
void printPerson1(Person<string, int>& p)
{
	p.showPerson();
}
void test01()
{
	Person<string, int>p1("孙悟空", 100);
	printPerson1(p1);
}

//2、参数模板化
template<class T1,class T2>
void printPerson2(Person<T1, T2>& p)
{
	p.showPerson();
	cout << "T1 的类型：" << typeid(T1).name() << endl;//string
	cout << "T2 的类型：" << typeid(T2).name() << endl;//int
}
void test02()
{
	Person<string, int>p1("猪八戒", 99);
	printPerson2(p1);
}

//将整个类模板化
template<class T>
void printPerson3(T& p)
{
	p.showPerson();
	cout << "T 的类型：" << typeid(T).name() << endl;//Person
}
void test03()
{
	Person<string,int>p("唐僧", 30);
	printPerson3(p);
}

int main()
{
	test01();
	test02();
	test03();
	system("pause");
	return 0;
	/*总结：
	* 1、通过类模板创建的对象，可以有参展方式向函数中进行传参
	* 2、使用广泛的是第一种：指定传入类型 void printPerson1(Person<string, int>& p)
	*/
}
```

### 3.5 类模板与继承

1. 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类T的类型
2. 如果不指定，编译器无法给子类分配内存
3. 如果想灵活指定出父类中 T 的类型，子类也需要变为类模板

```cpp
#include<iostream>
using namespace std;

template<class T>
class Base
{
public:
	T m;
};

//class Son :public Base//缺少类模板Base的参数列表,必须知道父类中 T的数据类型，才能继承给子类再分配内存空间
class Son:public Base<int>//必须指定一个类型
{};
void test01()
{
	Son s1;
}

//如果想灵活指定出父类中 T 的类型，子类也需要变为类模板
template<class T1,class T2>
class Son2 :public Base<T1>
{
public:
	Son2()
	{
		cout << "T1 的数据类型：" << typeid(T1).name() << endl;//int
		cout << "T2 的数据类型：" << typeid(T2).name() << endl;//char
	}
	T1 obj;
};
void test02()
{
	Son2<int,char> s2;//子类创建时，指定类型传递给父类
}

int main()
{
	test01();
	test02();
	system("pause");
	return 0;
	//总结：如果父类是类模板，子类需要指定出父类中 T 的数据类型
}
```

### 3.6 类模板成员函数的类外实现

```cpp
#include<iostream>
using namespace std;
/*类模板成员函数的类外实现
*/
template<class T1,class T2>
class Person
{
public:
	Person(T1 name, T2 age);//构造函数 类内声明

	void showPerson();//成员函数 类内声明

	T1 m_Name;
	T2 m_Age;
};
//构造函数 类外实现
template<class T1,class T2>
Person<T1, T2>::Person(T1 name, T2 age)
{
		this->m_Name = name;
		this->m_Age = age;
}
//成员函数 类外实现
template<class T1, class T2>
void Person<T1,T2>::showPerson()//<T1,T2>写在 :: 前面
{
		cout << "姓名：" << this->m_Name << "\t年龄：" << this->m_Age << endl;
}
void test01()
{
	Person<string,int> p("Tom", 18);
	p.showPerson();
}

int main()
{
	test01();
	system("pause");
	return 0;
	//总结：类模板中的成员函数类外实现，需要加上模板参数列表
}
```

### 3.7 类模板分文件编写

类模板中成员函数创建时机是在 调用阶段，导致分文件编写时链接不到

**解决办法：1、直接包含.cpp源文件**

```cpp
// Person.h
#pragma once
#include<iostream>
using namespace std;

template<class T1, class T2>
class Person
{
public:
	Person(T1 name, T2 age);

	void showPerson();

	T1 m_Name;
	T2 m_Age;
};
```

```cpp
// Person.cpp
#include<iostream>
#include"Person.h"
using namespace std;

template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age)
{
	this->m_Name = name;
	this->m_Age = age;
}

template<class T1, class T2>
void Person<T1, T2>::showPerson()
{
	cout << "姓名：" << this->m_Name << "\t年龄：" << this->m_Age << endl;
}
```

```cpp
#include<iostream>
using namespace std;
#include"Person.cpp"
int main()
{
	Person<string, int>p("Jerry", 21);
	p.showPerson();
	system("pause");
	return 0;
}
```

**解决办法：2、将声明.h和实现.cpp写到同一个文件中，并更改后缀名为.hpp，.hpp是约定的名称，并非强制**

```cpp
#pragma once
#include<iostream>
using namespace std;

template<class T1, class T2>
class Person
{
public:
	Person(T1 name, T2 age);

	void showPerson();

	T1 m_Name;
	T2 m_Age;
};

template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age)
{
	this->m_Name = name;
	this->m_Age = age;
}

template<class T1, class T2>
void Person<T1, T2>::showPerson()
{
	cout << "姓名：" << this->m_Name << "\t年龄：" << this->m_Age << endl;
}
```

```cpp
void test01()
{
	Person<string, int>p("Jerry", 21);
	p.showPerson();
}

int main()
{
	test01();
	system("pause");
	return 0;
	//总结：主流方法第二种，将类模板成员函数写到一起，并将后缀名改为.hpp
}
```

**解决办法：3、模板具现化，前提是你知道模板会有哪些具现化类型，并事先显示（或隐式）具现化出来**

```cpp
#pragma once
#include<iostream>
using namespace std;

template<class T1, class T2>
class Person
{
public:
	Person(T1 name, T2 age);

	void showPerson();

	T1 m_Name;
	T2 m_Age;
};

template<string,int> 

template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age)
{
	this->m_Name = name;
	this->m_Age = age;
}

template<class T1, class T2>
void Person<T1, T2>::showPerson()
{
	cout << "姓名：" << this->m_Name << "\t年龄：" << this->m_Age << endl;
}
```



### 3.8 类模板与友元

类模板与友元 掌握类模板配合友元函数的类内和类外实现
* 全局函数类内实现 - 直接在类内声明友元即可
* 全局函数类外实现 - 需要提前让编译器知道全局函数的存在

```cpp
#include<iostream>
using namespace std;

//提前让编译器知道Person类存在
template<class T1,class T2> class Person;

//2、全局函数类内声明 类外实现
template<class T1, class T2>
void printPerson1(Person<T1, T2> p)
{
	cout << "姓名：" << p.m_Name << "\t年龄" << p.m_Age << endl;
}

//通过全局函数，打印Person信息
template<class T1,class T2>
class Person
{
	//全局函数配合友元 类内实现
	friend void printPerson(Person<T1,T2> p)
	{
		cout << "姓名：" << p.m_Name << "\t年龄" << p.m_Age << endl;
	}

	//全局函数配合友元类内声明 类外实现
	//加 空模板 参数列表
	//如果是全局函数 类外实现 需要让编译器提前知道这个函数的存在
	friend void printPerson1<>(Person<T1, T2> p);

public:
	Person(T1 name, T2 age)
	{
		this->m_Name = name;
		this->m_Age = age;
	}

private:
	T1 m_Name;
	T2 m_Age;
};

//1、全局函数在类内实现
void test01()
{
	Person<string, int>p("Jerry", 22);
	printPerson(p);
}
//2、全局函数在类外实现
void test02()
{
	Person<string, int>p("Jerry", 23);
	printPerson1(p);
}

int main()
{
	test01();
	test02();
	system("pause");
	return 0;
	//总结：建议全局函数做类内实现，用法简单，编译器可以直接识别
}
```


## 参考

https://zhuanlan.zhihu.com/p/381299879