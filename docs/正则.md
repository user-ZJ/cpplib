# 正则

C++正则包括：

match:字符串和规则恰好对应

search:只要字符串中有目标出现就会返回，而非完全「匹配」

tokenize:分词/切割，例如有一组数据保存着许多邮箱账号，并以逗号分隔，那就可以指定以逗号为分割符来切割这些内容，从而得到每个账号

replace:将正则表达式内容替换为指定内容

## 匹配（Match）

```txt
bool ret = std::regex_match(target, reg);
target可以是string或char数组，如果target完全符合正则表达式，则返回true
bool ret = std::regex_match(target, matchs,reg);
target可以是string或char数组，如果target完全符合正则表达式，则返回true，并将匹配及结果存储再matchs中，target是string，则使用smatch,是字符数组使用cmatch。同时还支持其相应的宽字符版本wcmatch和wsmatch。
```

```cpp
std::regex reg("<.*>.*</.*>");
bool ret = std::regex_match("<html>value</html>", reg);
assert(ret);
////////////////////////// split ////////////////////
std::cmatch m;
auto ret = std::regex_match("<xml>value</xml>", m, std::regex("<(.*)>(.*)</(\\1)>"));
if (ret)
{
	std::cout << m.str() << std::endl;
	std::cout << m.length() << std::endl;
	std::cout << m.position() << std::endl;
}
std::cout << "----------------" << std::endl;
// 遍历匹配内容
for (auto i = 0; i < m.size(); ++i)
{
	// 两种方式都可以
	std::cout << m[i].str() << " " << m.str(i) << std::endl;
}
std::cout << "----------------" << std::endl;
// 使用迭代器遍历
for (auto pos = m.begin(); pos != m.end(); ++pos)
{
	std::cout << *pos << std::endl;
}
```

## 搜索（Search）

```txt
bool ret = std::regex_search(target, matchs, reg);
查找第一个和正则表达式匹配的位置，如果找到，返回true，并将结果存储到matchs中；否则返回false
```

```cpp
// 查找第一次匹配的内容
std::regex reg("<(.*)>(.*)</(\\1)>");
std::cmatch m;
auto ret = std::regex_search("123<xml>value</xml>456", m, reg);
if (ret)
{
	for (auto& elem : m)
		std::cout << elem << std::endl;
}
std::cout << "prefix:" << m.prefix() << std::endl;  //匹配结果之前的所有内容
std::cout << "suffix:" << m.suffix() << std::endl;  //匹配结果之后的所有内容
// 查找所有匹配的内容
std::regex reg("<(.*)>(.*)</(\\1)>");
std::string content("123<xml>value</xml>456<widget>center</widget>hahaha<vertical>window</vertical>the end");
std::smatch m;
auto pos = content.cbegin();
auto end = content.cend();
for (; std::regex_search(pos, end, m, reg); pos = m.suffix().first)  //继续匹配后面的字符串
{
	std::cout << "----------------" << std::endl;
	std::cout << m.str() << std::endl;
	std::cout << m.str(1) << std::endl;
	std::cout << m.str(2) << std::endl;
	std::cout << m.str(3) << std::endl;
}
```

## 分词（Tokenize）

还有一种操作叫做「切割」，例如有一组数据保存着许多邮箱账号，并以逗号分隔，那就可以指定以逗号为分割符来切割这些内容，从而得到每个账号。

而在C++的正则中，把这种操作称为Tokenize，用模板类regex_token_iterator<>提供分词迭代器，

```cpp
std::string mail("123@qq.vip.com,456@gmail.com,789@163.com,abcd@my.com");
std::regex reg(",");
std::sregex_token_iterator pos(mail.begin(), mail.end(), reg, -1);
decltype(pos) end;
for (; pos != end; ++pos)
{
	std::cout << pos->str() << std::endl;
}
```

sregex_token_iterator是针对string类型的特化，需要注意的是最后一个参数，这个参数可以指定一系列整数值，用来表示你感兴趣的内容，此处的-1表示对于匹配的正则表达式之前的子序列感兴趣；而若指定0，则表示对于匹配的正则表达式感兴趣，这里就会得到“,"

## 替换（Replace）

```txt
result = std::regex_replace(data, reg, replace);
result为替换后的字符串，replace为要替换正则表达式匹配的内容。
```

```cpp
// 删除.
char data[] = "he...ll..o, worl..d!";
std::regex reg("\\.");
// output: hello, world!
std::cout << std::regex_replace(data, reg, "");
// 使用分组功能
char data[] = "001-Neo,002-Lucia";
std::regex reg("(\\d+)-(\\w+)");
// output: 001 name=Neo,002 name=Lucia
std::cout << std::regex_replace(data, reg, "$1 name=$2");
```

## 中文处理

如果对中文字符串进行正则匹配，则需要将字符串转换为wstring，匹配完后再转回string

匹配的时候用std::wmatch和std::wregex

```cpp
//wstring 和string相互转换
#include <string>
#include <codecvt>
#include <locale>
using convert_t = std::codecvt_utf8<wchar_t>;
std::wstring_convert<convert_t, wchar_t> strconverter;

std::string to_string(std::wstring wstr)
{
    local lc("zh_CN.UTF-8");
    local::global(lc);
    wcout<<wstr<<endl;
    return strconverter.to_bytes(wstr);
}

std::wstring to_wstring(std::string str)
{
    return strconverter.from_bytes(str);
}
```

```cpp
std::wregex re(LR"([a-zA-Z]:\\[\.\w-_\u4e00-\u9fa5\\]*)");
std::wstring subject = L"D:\\Tools\\软件\\xournalpp-1.0.17-windows";
wsmatch matchs;
foundmatch = std::regex_search(subject, matchs,re);
```





## 参考

https://www.cnblogs.com/coolcpp/p/cpp-regex.html

https://riptutorial.com/cplusplus/example/4190/conversion-to-std--wstring