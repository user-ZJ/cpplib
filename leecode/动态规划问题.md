# 动态规划

动态规划问题的**一般形式就是求最值**,比如说让你求最⻓递增子序列,最小编辑距离等等。

求解动态规划的**核心问题是穷举**。因为要求最值,肯定要把所有可行的答案穷举出来,然后在其中找最值。

动态规划的穷举有点特别,因为这类问题存在「重叠子问题」,如果暴力穷举的话效率会极其低下,所以需要「备忘录」或者「DP table」来优化穷举过程,避免不必要的计算。

动态规划问题一定会具备「最优子结构」,才能通过子问题的最值得到原问题的最值

虽然动态规划的核心思想就是穷举求最值,但是问题可以千变万化,穷举所有可行解其实并不是一件容易的事,只有列出正确的「状态转移方程」才能正确地穷举。

**重叠子问题、最优子结构、状态转移方程**就是动态规划三要素。

思考状态转移方程:
明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case。

某种程度上说,动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质,可以用 dp table 或者备忘录优化,将递归树大幅剪枝,这就变成了动态规划。而今天的两个问题,都没有重叠子问题,也就是回溯算法问题了,复杂度非常高是不可避免的



## 最长公共子串

```text
int dp[str1.length+1][str2.length+1];
dp[i][j]表示str1[0:i-1]和str2[0:j-1]的最长公共子串
初始值为：
for(int i = 0; i <= m; ++i) dp[i][0] = 0;
for(int j = 0; j <= n; ++j) dp[0][j] = 0;
递推条件为：
if(str1[i-1] == str2[j-1]) dp[i][j] = dp[i-1][j-1] + 1;
else dp[i][j] = 0;
记录dp[i][j]中最大的值和对应的index，即可算出公共子串
```

## 最长公共子序列

```text
int dp[str1.length+1][str2.length+1];
dp[i][j]表示str1[0:i-1]和str2[0:j-1]的最长公共子序列
初始值为：
for(int i = 0; i <= m; ++i) dp[i][0] = 0;
for(int j = 0; j <= n; ++j) dp[0][j] = 0;
递推条件为：
if s1[i]==s2[j] dp[i][j] = dp[i-1][j-1] + 1
else dp[i][j] = max(dp[i-1][j],dp[i][j-1])

```

## 最小编辑代价

```text
int dp[str1.length+1][str2.length+1];
dp[i][j] str1[0:i] 和str2[0:j]的最小编辑代价
初始值为：
for(int i=1;i<=m;i++) dp[i][0] = i*dc;  //dc为删除代价
for(int j=1;j<=n;j++) dp[0][j] = j*ic;  //ic为插入代价
if s1[i]==s2[j] dp[i][j] = dp[i-1][j-1];
else 
dp[i][i] = min{
     dp[i-1][j] + ic  插入
     dp[i][j-1] + dc  删除
     dp[i-1][j-1] + rc 替换
}
```

## 求路径

```text
一个机器人在m×n大小的地图的左上角（起点）。
机器人每次向下或向右移动。机器人要到达地图的右下角（终点）。
可以有多少种不同的路径从起点走到终点？
```

```text
dp[m][n]  从[0,0]到达[m-1][n-1]位置的路径总数
初始值：
for(i=0;i<m;i++) dp[i][0] = 1;
for(j=0;j<n;j++) dp[0][j] = 1;
递推公式
dp[i][j] == dp[i-1][j] + dp[i][j-1]
```

## 最长回文子串

```text
对于一个字符串，请设计一个高效算法，计算其中最长回文子串的长度。
给定字符串A以及它的长度n，请返回最长回文子串的长度。
```

```text
dp[i][j]是一个bool类型的变量数组，如果dp[i][j]==true,那么他表示字符串str从str[i]到str[j]是回文串
边界是：
dp[i][i]=true,
dp[i][i+1]=(str[i]==str[i+1]) ? true , false
状态转移方程：
dp[i][j]=true if( dp[i+1][j-1] && str[i]==str[j] )
dp[i][j]=false if( str[i]!=str[j] )
```

## 最长递增子序列

```text
给定数组arr，设长度为n，输出arr的最长递增子序列。（如果有多个答案，请输出其中字典序最小的）
```

```text
dp[i] 是以arr[i]为尾元素的最长子序列的长度。
边界值
dp[0] = 1;
状态转移方程
for(int i=0;i<arr.size();i++){
    for(int j=0;j<i;j++){
        if(arr[i]>arr[j]){
            dp[i] = max(dp[i],dp[j]+1);
            maxlen = max(maxlen,dp[i]);
        }else dp[i]=1;
    }
}
```

## 子数组最大累加和

```text
给定一个数组arr，返回子数组的最大累加和
例如，arr = [1, -2, 3, 5, -2, 6, -1]，所有子数组中，[3, 5, -2, 6]可以累加出最大的和12，所以返回12.
题目保证没有全为负数的数据
[要求]
时间复杂度为O(n)，空间复杂度为O(1)O(1)
```

```text
dp[i] 数组arr[0:i]的最大累加和
边界值：
dp[0] = arr[0]
状态转移方程
dp[i] = max(dp[i-1]+arr[i],arr[i])
```

## 高楼扔鸡蛋问题

```cpp
一座大楼有0-N层，地面算作第0层，最高的一层为第N层。
已知鸡蛋从第0层掉落肯定不会摔碎，从第i层掉落可能会摔碎，也可能不会摔碎。
给定整数N作为楼层数，再给定整数K作为鸡蛋数，
返回如果想找到鸡蛋不会摔碎的最高层数，即使在最差的情况下扔的最小次数。
（一次只能扔一个鸡蛋）。
```

```text
dp[i][j]表示最高楼层为i层，j枚棋子，最差的情况下扔的最小次数
边界值：
for(int i=0;i<=n;i++) dp[i][0]=0;
for(int j=0;j<=k;j++) dp[0][j]=0;
for(int i=1;i<=n;i++) dp[i][1] = i;  k=1时，最多尝试N次
状态转移方程
dp[i][j] = min(max(dp[0:i-1][j-1],dp[i-1:0][j]))+1
```

```cpp
int solve(int n, int k) {
        // write code here
        if(n<1 || k<1)
            return 0;
        if(k==1) return n;
        int dp[n+1][k+1];
        for(int i=0;i<=n;i++) dp[i][0]=0;
        for(int j=0;j<=k;j++) dp[0][j]=0;
        for(int i=1;i<=n;i++){
            dp[i][1] = i;
        }
        for(int i=1;i<=n;i++){
            for(int j=2;j<=k;j++){
                int mm = 0x7fffffff;
                for(int t=1;t<=i;t++){
                    mm = min(mm,max(dp[t-1][j-1],dp[i-t][j]));
                }
                dp[i][j]=mm+1;
            }
        }
        return dp[n][k];
}
```

## 最长的括号子串

```text
给出一个仅包含字符'('和')'的字符串，计算最长的格式正确的括号子串的长度。
对于字符串"(()"来说，最长的格式正确的子串是"()"，长度为2.
再举一个例子：对于字符串")()())",来说，最长的格式正确的子串是"()()"，长度为4.
```

```text
dp[i] 表示以下标i结尾的字符串的最长有效括号的长度
边界值：
dp数组都初始化为0
状态转移方程：
1. 以“（”结尾的字符串dp值为0
2. 以“()”结尾，s[i]=='(' && s[i-1]==')'
dp[i]=dp[i-2]+2
3. 以“))”结尾，如果s[i-1-dp[i-1]]=='('
dp[i] = dp[i-1]+dp[i-2-dp[i-1]]+2
```

```cpp
int longestValidParentheses(string s) {
        // write code here
        int maxans = 0;
        int dp[s.length()];
        for(int i=0;i<s.length();i++) dp[i]=0;
        for (int i = 1; i < s.length(); i++) {
            if (s[i] == ')') {
                if (s[i - 1] == '(') {
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
                } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(') {
                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                }
                maxans = max(maxans, dp[i]);
            }
        }
        return maxans;
}
```

## 凑零钱问题

```text
给定数组arr，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个aim，代表要找的钱数，求组成aim的最少货币数。
如果无解，请返回-1.
```

```text
dp[i]表示当前目标金额为i时，至少需要x枚硬币
边界值：
dp[0] = 0
dp[n] = -1 if n<0
状态转移方程：
dp[n] = min{dp[n-coin]+1 | coin属于coins} n>0
```

```cpp
int minMoney(vector<int>& arr, int aim) {
        // write code here
        int N = aim + 1;
        vector<int> dp(N,0x7fffffff);
        dp[0] = 0;
        for(int i=0;i<N;i++){
            for(int j=0;j<arr.size();j++){
                if(i-arr[j]<0) continue;
                dp[i] = min(dp[i-arr[j]]+1,dp[i]);
            }
        }
        int res = (dp[N-1]==0x7fffffff)?-1:dp[N-1];
        return res;
}
```

