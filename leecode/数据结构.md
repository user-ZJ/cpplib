# 数据结构

## 二维数组查找

```text
已知int一个有序矩阵mat，同时给定矩阵的大小n和m以及需要查找的元素x，且矩阵的行和列都是从小到大有序的。设计查找算法返回所查找元素的二元数组，代表该元素的行号和列号(均从零开始)。保证元素互异。
```

```text
思路：
首先选取矩阵中右上角的数字，如果该数字等于要查找的数字，查找结束，如果该数字大于要查找的数组，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。
同理从左下角开始查找也可以
```

```cpp
vector<int> findElement(vector<vector<int> > mat, int n, int m, int x) {
        // write code here
        vector<int> res;
        int row=0,col=m-1;
        while(row<n && col>=0){
            if(mat[row][col]==x){
                res.push_back(row);
                res.push_back(col);
                return res;
            }else if(mat[row][col]>x){
                col--;
            }else{
                row++;
            }
        }
        return res;
}
```

## 二分查找

### 查找值

```cpp
int binary_search(vector<int> nums,int target){
    if(nums.size()==0) return -1;
    int left=0,right=nums.size()-1;
    while(left<=right){
        int mid = (left+right)/2;
        if(nums[mid]==target){
            return mid;
        }else if(nums[mid]>target){
            left = mid +1;
        }else{
            right = mid - 1;
        }
    }
    return -1;
}
```

### 查找左边界

```cpp
int left_bound(vector<int> nums,int target){
    if(nums.size()==0) return -1;
    int left=0,right=nums.size()-1;
    while(left<=right){
        int mid = (left+right)/2;
        if(nums[mid]==target){
            right = mid -1;
        }else if(nums[mid]>target){
            left = mid +1;
        }else{
            right = mid - 1;
        }
    }
    if(left>=nums.size || nums[left]!=target)
        return -1;
    return left;
}
```

### 查找右边界

```cpp
int right_bound(vector<int> nums,int target){
    if(nums.size()==0) return -1;
    int left=0,right=nums.size()-1;
    while(left<=right){
        int mid = (left+right)/2;
        if(nums[mid]==target){
            left = mid +1;
        }else if(nums[mid]>target){
            left = mid +1;
        }else{
            right = mid - 1;
        }
    }
    if(right<0 || nums[right]!=target)
        return -1;
    return right;
}
```



### 旋转数组最小值(二分)

```text
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
```

```text
这里我们把target 看作是右端点，来进行分析，那就要分析以下三种情况，看是否可以达到上述的目标。

情况1，arr[mid] > target：4 5 6 1 2 3
arr[mid] 为 6， target为右端点 3， arr[mid] > target, 说明[first ... mid] 都是 >= target 的，因为原始数组是非递减，所以可以确定答案为 [mid+1...last]区间,所以 first = mid + 1
情况2，arr[mid] < target:5 6 1 2 3 4
arr[mid] 为 1， target为右端点 4， arr[mid] < target, 说明答案肯定不在[mid+1...last]，但是arr[mid] 有可能是答案,所以答案在[first, mid]区间，所以last = mid;
情况3，arr[mid] == target:
如果是 1 0 1 1 1， arr[mid] = target = 1, 显然答案在左边
如果是 1 1 1 0 1, arr[mid] = target = 1, 显然答案在右边
所以这种情况，不能确定答案在左边还是右边，那么就让last = last - 1;慢慢缩少区间，同时也不会错过答案。
```

```cpp
int minNumberInRotateArray(vector<int> rotateArray) {
        if(rotateArray.size()==0) return 0;
        int first=0,last=rotateArray.size()-1;
        while(first<last){
            if(rotateArray[first]<rotateArray[last]){  //未进行旋转
                return rotateArray[first];
            }
            int mid = (first+last)/2;
            if(rotateArray[mid]>rotateArray[last]){  //最小元素位于mid右侧
                first = mid +1;
            }else if(rotateArray[mid]<rotateArray[last]){  //mid可能是最小的元素
                last = mid;
            }else{
                --last;
            }
        }
        return rotateArray[first];
}
```

### 旋转数组查找(二分)

```text
给出一个转动过的有序数组，你事先不知道该数组转动了多少
(例如,0 1 2 4 5 6 7可能变为4 5 6 7 0 1 2).
在数组中搜索给出的目标值，如果能在数组中找到，返回它的索引，否则返回-1。
假设数组中不存在重复项。
```

```text
对旋转数组进行均等划分后，总有一边是有序的
我们定位到有序的一边后，对比target与有序子数组的左右边界，就可以作出搜索左侧还是右侧的决策。
```

```cpp
int search(int* A, int n, int target) {
        // write code here
        int left = 0, right = n - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (A[mid] == target) return mid;
            if (A[mid] >= A[left]) {
                // 左侧有序(含A[mid])
                if (A[mid] > target && A[left] <= target)
                    right = mid - 1;
                else
                    left = mid + 1;
            } else {
                // 右侧有序(含A[mid])
                if (A[mid] < target && A[right] >= target)
                    left = mid + 1;
                else
                    right = mid - 1;
            }
        }
        return -1;
}
```

## 数组中重复的数字

```text
在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有哪几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2，3，1，0，2，5，3}，那么对应的输出是重复的数字2或者是3。
```

```text
数组里所有的数组都是0到n-1的范围内。如果数组里没有重复的数字，那么每个数字排序后的数字i都会在下标为i的位置上。由于数组中有重复的数字，那么这个位置上就会有多个数字，有些位置上也会没有数字。
从头到尾扫描这个数组的每个数字。当到下标为i的数字时，先比较这个数字m是否等于下标i，如果等于那么就扫描下一个数字；如果不是，那它和第m个数字相比较。如果和第m个数字一样，则找到重复的数字，因为该数字在第i个位置和第m个位置都出现了；如果不是则把该第i位置上的数字和第m个位置上的数字交换，刚在它原本属于的位置上去。重复此过程，找到重复的数字。
```

```cpp
bool duplicate(int nums[],int len,int *duplication){
      if(nums==nullptr || len<0){
          return false;
      }
      for(int i=0;i<len;i++){
          if(nums[i]<0 || nums[i]>len-1)
              return false;
      }
      for(int i=0;i<len;i++){
          while(nums[i]!=i){
              if(nums[i]==nums[nums[i]]){
                  *duplication = nums[i];
                  return true;
              }else{
                  swap(nums[i],nums[nums[i]]);
              }
          }
      }
}
```

## 替换空格

```text
请实现一个函数，把字符串中的每个空格替换成"%20"。例如输入“We are happy.”，则输出“We%20are%20happy.”。　
```

```text
Step1.先遍历一次字符串，这样就能统计出字符串中空格的总数，并可以由此计算出替换之后的字符串的总长度。
Step2.从字符串的后面开始复制和替换。
```

```cpp
void ReplaceBlank(char str[],int len){
    if(str==nullptr || len<=0)
        return;
    int originalLen=0,blankCount=0;
    int i=0;
    while(str[i++]!='\0'){
        originalLen++;
        if(str[i]==' ')
            blankCount++;
    }
    int newLen = originalLen + 2*blankCount;
    if(newLen>len)
        return;
    int index1 = originalLen;
    int index2 = newLen;
    while(index1>=0 && index2>=0){
        if(str[index1]==' '){
            str[index2--] = '0';
            str[index2--] = '2';
            str[index2--] = '%';
            index1--;
        }else{
            str[index2--] = str[index1--];
        }
    }
}
```

## 从尾到头打印链表

```text
输入一个链表的头结点，从尾到头反过来打印出每个结点的值。
```

```text
解法一：反转链表，再从头打印，需要修改原链表内容
解法二：先遍历一遍链表，将数据记录在栈中，再从栈中弹出数据，不修改原链表的内容，增加了一个容量为N的栈
解法三：使用递归，访问每个节点的时候先递归输出后面的节点，但是当链表非常长的时候，可能会导致调用栈溢出。
```

## 重建二叉树--分治、递归

```text
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
```

```text
从前序遍历可知，前序遍历数组pre的首元素就是二叉树的根结点，然后根据根结点的值在中序遍历中找到根结点的位置，那么根结点左边就为左子树的序列，根结点右边就是右子树的序列。
使用同样的方法构建左右子树。
```

```cpp
TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        return rebuild(pre, 0, pre.size()-1, vin, 0, vin.size()-1);
}
    
TreeNode *rebuild(vector<int> &pre,int pre_l,int pre_r,vector<int> &vin,int vin_l,int vin_r){
        if(pre_l>pre_r) return nullptr;
        TreeNode *root = new TreeNode(pre[pre_l]);
        int root_index;
        for(root_index=vin_l;root_index<=vin_r;root_index++){
            if(vin[root_index]==root->val)
                break;
        }
        root->left= rebuild(pre, pre_l+1, pre_l+root_index-vin_l, vin, vin_l, root_index-1);
        root->right = rebuild(pre, pre_l+root_index-vin_l+1, pre_r, vin, root_index+1, vin_r);
        return root;
}
```

## 二叉树的下一个节点

```text
给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
```

```text
1.node节点有右孩子。下一个结点就是以node结点的右孩子为根的子树中的最左下结点
2.node 节点没有右孩子时，node节点是其父结点的左孩子。
3.node 节点没有右孩子时，node节点是其父结点的右孩子，可以沿着指向父节点的指针一直向上遍历，直到找到一个是它父节点的左子节点的节点，如果存在即为下一个节点，否则为空。
```

## 两个栈实现队列

```text
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
```

```text
push操作就直接往stack1中push， pop操作需要分类一下：如果stack2为空，那么需要将stack1中的数据转移到stack2中，然后在对stack2进行pop，如果stack2不为空，直接pop就ok。
```

```cpp
class Solution
{
public:
    void push(int node) {
        stack1.push(node);
    }

    int pop() {
        if(stack2.empty()){
            while(!stack1.empty()){
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
        int ret = stack2.top();
        stack2.pop();
        return ret;
    }

private:
    stack<int> stack1;
    stack<int> stack2;
};
```

## 二进制中1的个数

```txt
输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。
```

```txt
把一个整数减去1，再和原整数做与运算，会把该整数最右边的1变成0。那么一个整数的二进制中有多少个1就可以进行多少次这样的操作
```

```cpp
int  NumberOf1(int n) {
         int res = 0;
         while(n){
             res++;
             n = n & (n-1);
         }
         return res;
}
```

## 数值的整数次方

```txt
给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。
不得使用库函数，同时需要考虑大数问题。
```

```txt
预处理：求pow(a, n)，如果n为负数怎么解决？
n为偶数，a^n = a^(n/2)*a^(n/2)
n为奇数，a^n = a^((n-1)/2)*a^((n-1)/2)*a
```

```cpp
double Power(double base, int exponent) {
        if(base==0.0 && exponent<0) //对0求倒数的情况
            return 0.0;
        int absExp = abs(exponent);
        double res = PowerExponent(base,absExp);
        if(exponent<0)
            res = 1.0/res;
        return res;
    }
    double PowerExponent(double base,int absExp){
        if(absExp==0)
            return 1.0;
        if(absExp==1)
            return base;
        double res = PowerExponent(base,absExp/2);
        res *= res;
        if(absExp & 0x1)  //奇数
            res *= base;
        return res;
}
```

## 打印从1到最大的N位数

```txt
输入数字n，按照顺序打印出从1到最大的n位十进制数，比如数组3，则打印1 2 3 一直到最大的3位数999
```

```txt
陷阱：当n很大时，需要考虑大数问题，需要使用字符串模型数字加法
```

```cpp
void Print1ToMaxOfNDigits(int n){
    if(n<=0)
        return;
    string number(n,'0');
    while(!Increment(number)){
        PrintNumber(number);
    }
}
bool Increment(string &number){
    bool isOverflow = false;
    int nTakeOwver = 0;
    int nLength = number.length();
    for(int i=nLength-1;i>=0;i--){
        int nSum = number[i]-'0'+nTakeOver;
        if(i==nLength-1)
            nSum += 1;
        if(nSum >= 10){
            if(i==0)
                isOverflow = true;
            else{
                nSum -= 10;
                nTakeOver = 1;
                number[i] = '0'+nSum;
            }
        }else{
            number[i] = '0' + nSum;
            break;
        }
    }
    return isOverflow;
}
void PrintNumber(string number){
    bool isBegining0 = true;
    int nLength = number.length();
    for(int i=0;i<nLength;i++){
        if(isBegining0&&number[i]!='0')
            isBegining0=false;
        if(!isBegining0)
            cout<<number[i];
    }
    cout<<"\t";
}
```

## 删除链表节点

```txt
给定单向链表的头指针和一个节点指针，定义一个函数再O(1)时间内删除该节点
```

```txt
把下一个节点的内容复制到需要删除的节点覆盖原来的内容，再把下一个节点删除
如果要删除的节点位于链表的尾部，仍然需要从链表的头结点开始，顺序遍历得到该节点的前序节点，并完成删除操作
如果链表中只有一个节点，而我们又要删除链表的头结点，那么再删除节点之后还需要把聊表的头结点设置为nullptr
```

```cpp
void DeleteNode(ListNode **head,ListNode *deleted){
    if(head==nullptr||deleted==nullptr)
        return;
    //要删除的节点不是尾节点
    if(deleted->next!=nullptr){
        ListNode *pnext = deleted->next;
        deleted->value = pnext->value;
        deleted->next = pnext->next;
        delete pnext;
        pnext = nullptr;
    }else if(*head==deleted){  //只有一个节点，删除头结点
        delete deleted;
        deleted = nullptr;
        *head = nullptr;
    }else{  //链表中有多个节点。删除尾节点
        ListNode *p = *head;
        while(p->next != deleted){
            p = p->next;
        }
        p->next = nullptr;
        delete deleted;
        deleted = nullptr;
    }
}
```

## 删除链表中重复节点

```txt
在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5
```

```cpp
ListNode* deleteDuplication(ListNode* pHead) {
        if (pHead == nullptr || pHead->next == nullptr) {
            return pHead;
        }
 
        ListNode* dummy = new ListNode(-1);
        dummy->next = pHead;
        ListNode* pre = dummy;
        ListNode* cur = nullptr;
        ListNode* temp = nullptr;
         
        while (pre->next != nullptr) {
            cur = pre->next;
            if (cur->next != nullptr && cur->next->val == cur->val) {
                int target = cur->val;
                while (cur != nullptr && cur->val == target) {
                    temp = cur;
                    cur = cur->next;
                    delete temp;
                }
                pre->next = cur;
            } else {
                pre = pre->next;
            }
        }
 
        return dummy->next;
}
```

