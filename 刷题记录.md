## 1. 反转链表

```cpp
ListNode* ReverseList(ListNode* pHead) {
        ListNode *pre = nullptr;
        ListNode *cur = pHead;
        ListNode *nex = nullptr; // 这里可以指向nullptr，循环里面要重新指向
        while (cur) {
            nex = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nex;
        }
        return pre;
    }
```

# 2. 快排

```cpp
#include<iostream>
#include<chrono>      //std::chrono::seconds
#include <shared_mutex>
#include <string>
#include <stdio.h> 
#include<map>
#include <unordered_map>


using namespace std;

void quickSort(int s[], int l, int r)
{
	if (l< r)
	{
		int i = l, j = r, x = s[l];
		while (i < j)
		{
			while (i < j && s[j] >= x) // 从右向左找第一个小于x的数
				j--;
			if (i < j)
				s[i++] = s[j];
			while (i < j && s[i]< x) // 从左向右找第一个大于等于x的数
				i++;
			if (i < j)
				s[j--] = s[i];
		}
		s[i] = x;
		quickSort(s, l, i - 1); // 递归调用
		quickSort(s, i + 1, r);
	}
}


void quicksort2(vector<int> &vec,int l,int r){
        if(l>=r) return;
        int label = vec[l];
        int lt=l,rt=r;
        while(lt<rt){
            while(lt<rt && vec[rt]>=label) rt--;
            while(lt<rt && vec[lt]<=label) lt++;
            if(lt<rt) swap(vec[lt],vec[rt]);
        }
        swap(vec[l],vec[lt]);
        quicksort2(vec, l, lt-1);
        quicksort2(vec, rt+1, r);
}

int main()
{   
	auto begin_t = std::chrono::steady_clock::now();
	int array[] = { 1,34,65,12,43,67,5,78,10,3,70 }, k;
	int len = sizeof(array) / sizeof(int);
	cout << "The orginal arrayare:" << endl;
	for (k = 0; k<len; k++)
		cout << array[k] << ",";
	cout << endl;
	quickSort(array, 0, len - 1);
	cout << "The sorted arrayare:" << endl;
	for (k = 0; k<len; k++)
		cout << array[k] << ",";
	cout << endl;

	auto finish_t = std::chrono::steady_clock::now();
	double timecost = std::chrono::duration<double, std::milli>(finish_t - begin_t).count();
	cout << timecost<< endl;
	
	system("pause");
    return 0;
}


```

