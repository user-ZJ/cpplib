# 多线程

## c++11多线程

```cpp
#include <iostream>
#include <thread>
std::thread::id main_thread_id = std::this_thread::get_id();
void hello()  
{
    std::cout << "Hello Concurrent World\n";
    if (main_thread_id == std::this_thread::get_id())
        std::cout << "This is the main thread.\n";
    else
        std::cout << "This is not the main thread.\n";
}
void pause_thread(int n) {
    std::this_thread::sleep_for(std::chrono::seconds(n));
    std::cout << "pause of " << n << " seconds ended\n";
}
int main() {
    std::thread t(hello);
    std::cout << t.hardware_concurrency() << std::endl;//可以并发执行多少个(不准确)
    std::cout << "native_handle " << t.native_handle() << std::endl;//可以并发执行多少个(不准确)
    t.join();
    std::thread a(hello);
    a.detach();
    std::thread threads[5];                         // 默认构造线程

    std::cout << "Spawning 5 threads...\n";
    for (int i = 0; i < 5; ++i)
        threads[i] = std::thread(pause_thread, i + 1);   // move-assign threads
    std::cout << "Done spawning threads. Now waiting for them to join:\n";
    for (auto &thread : threads)
        thread.join();
    std::cout << "All threads joined!\n";
}
```

```
g++ -std=c++11 test.cpp -lpthread
```

## omp

使用omp来使用多线程。它的好处是跨平台，使用简单。

在Linux平台上，如果需要使用omp，只需在编译时使用"-fopenmp"指令。在Windows的visual studio开发环境中，开启omp支持的步骤为“项目属性 -> C/C++ -> 所有选项 -> openmp支持 -> 是(/openmp)”。

openmp是由一系列#paragma指令组成，这些指令控制如何多线程的执行程序。另外，即使编译器不支持omp，程序也也能够正常运行，只是程序不会多线程并行运行

所有的omp指令都是以"#pragma omp“开头，换行符结束。并且除了barrier和flush两个指令不作用于代码以外，其他的指令都只与指令后面的那段代码相关

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main()
{
 #pragma omp parallel for
    for (int i = 0; i < 10; ++i)                                                                                                                                                                            
    {   
       printf("%d ", i); 
    }   
    return 0;
}
```

```shell
g++ -std=c++11 -fopenmp omp.cc
```

### omp语法

* parallel 

parallel告诉编译器开始 一个并行块，编译器会创建一个包含N（在运行时决定，通常为硬件线程数）个线程的线程组，所有线程都运行接下来的语句或者由”{...}"包含的代码块，在这执行结束之后，又回到主线程，创建的这N个线程会被回收

GCC编译器的实现方式是在内部创建一个函数，然后将相关的执行代码移至这个函数，这样一来代码块中定义的变量成为了线程的局部变量，互不影响

parallel指令所创建的线程组的线程数默认是有编译器决定的，我们也可以通过num_threads指令来指定线程数，如”#pragma omp parallel num_threads(3)“即告诉编译器，此处需要创建一个包含3个线程的线程组

* for

omp中的for指令用于告诉编译器，拆分接下来的for循环，并分别在不同的线程中运行不同的部分。如果for指令后没有紧接着for循环，编译器会报错

```cpp
#pragma omp parallel  
 {
#pragma  omp for
  for (int i = 0; i < 10; ++i)
  {
   printf("%d ", i);
  }
//如果此处没有#pragma omp parallel指令，那么for循环只会在主线程中执行
```

* Schedule

Schedule指令提供对for指令中线程调度更多的控制能力。它有两种调度方式：static和dynamic

**static**：每个线程自行决定要执行哪个块，即每个线程执行for循环中的一个子块。

**dynamic**：一个线程并不是执行for循环的一个子块，而是每次都向omp运行时库索取一个for循环中的迭代值，然后执行这次迭代，在执行完之后再索取新的值。因此，线程有可能执行任意的迭代值，而不是一个子块。

”#pragma omp parallel for“实际上的效果是”#pragma omp parallel for schedule(static)"。如果我们将之前的示例采用dynamic调度方式，即”#pragma omp parallel for schedule(dynamic)"

在dynamic调度方式中，还可以指定每次索取的迭代值数量,如：“#pragma omp parallel  for schedule(dynamic，3)”

每个线程每次都索取3个迭代值。执行完之后，再拿3个迭代值，直到for循环所有迭代值都运行结束。在最后一次索取的结果有可能不足3个。

* ordered

ordered指令用于控制一段代码在for循环中的执行顺序，它保证这段代码一定是按照for中的顺序依次执行的

```cpp
#pragma  omp parallel for ordered schedule(dynamic)
for (int i = 0; i < 10; ++i)
{
    Data data = ReadFile(files[i]);
#pragma omp ordered
    PutDataToDataset(data);
}
```

这个循环负责读取10个文件，然后将数据放入一个内存结构中。读文件的操作是并行的，但是将数据存入内存结构中则是严格串行的。即先存第一个文件数据，然后第二个...，最后是第十个文件。假设一个线程已经读取了第七个文件的，但是第六个文件还没有存入内存结构，那么这个线程会阻塞，知道第六个文件存入内存结构之后，线程才会继续运行。

在每一个ordered for循环中，有且仅有一个“#pragma omp ordered"指令限定的代码块。

* section

section指令用于指定哪些程序块可以并行运行。一个section块内的代码必须串行运行，而section块之间是可以并行运行的。

* task

当觉得for和section指令用着不方便时，可以用task指令。它用于告诉编译器其后续的指令可以并行运行

* atomic

atomic指令用于保证其后续的语句执行时原子性的。所谓原子性，即事务的概念，它的执行不可拆分，要么执行成功，要么什么都没有执行

atomic只能用于简单的表达式，比如+=、-=、*=、&=等，它们通常能够被编译成一条指令。

* critical

critical指令用于保证其相关联的代码只在一个线程中执行。另外，我们还可以给critical指令传递一个名称，这个名称是全局性的，所有具有相同名字的critical相关联的代码保证不会同时在多个线程中运行，同一时间最多只会有一个代码块在运行。如果没有指定名称，那系统会给定一个默认的名称

* 锁

omp运行库提供了一种锁：omp_lock_t，它定义在omp.h头文件中。针对omp_lock_t有5中操作，它们分别是：

`omp_init_lock` 初始化锁，初始化后锁处于未锁定状态.

`omp_destroy_lock` 销毁锁，调用这个函数时，锁必须是未锁定状态.

`omp_set_lock` 尝试获取锁，如果锁已经被其他线程加锁了，那当前线程进入阻塞状态。

`omp_unset_lock` 释放锁，调用这个方法的线程必须已经获得了锁，如果当前线程没有获得锁，则会有未定义行为。

`omp_test_lock` a尝试获取锁，获取锁成功则返回1，否则返回0.

omp_lock_t相当于mutex,如果线程已经获得了锁，那在释放锁之前，当前线程不能对锁进行上锁。为了满足这种递归锁的需求，omp提供了omp_nest_lock_t，这种锁相当于recursive_mutex可以递归上锁，但是释放操作必须与上锁操作一一对应，否则锁不会得到释放。

* flush

多线程之间共享变量

private`, `firstprivate,lastprivate` 及 `shared指令控制变量共享方式

其中private,firstprivate,lastprivate表示变量的共享方式是私有的，即每个线程都有一份自己的拷贝；而shared表示线程组的线程访问的是同一个变量

* default

default命令用于设置所有变量的默认的共享方式，如default(shared)表示所有变量默认共享方式为shared

使用default(none)来检查我们是否显示设置了所有使用了的变量的共享方式

default中的参数不能使用private、firstprivate以及lastprivate。

```cpp
int a, b=0;
#pragma omp parallel default(none) shared(b)
{
   b += a;
}
//以上代码无法通过编译，因为在parallel的代码块中使用了变量a和b，但是我们只设置了b的共享方式，而没有设置变量a的共享方式
```

* reduction

reductino指令是private,shared及atomic的综合体。它的语法是：

  reduction(operator : list)

其中operator指操作符，list表示操作符要作用的列表，通常是一个共享变量名，之所以称之为列表是因为线程组中的每个线程都有一份变量的拷贝，reduction即负责用给定的操作符将这些拷贝的局部变量的值进行聚合，并设置回共享变量。

**Operator**可以是：+`, `-`, `|`, `^`, `||,*`, `&&,&

```cpp
//阶乘的多线程的实现
int factorial(int number)
{
int fac =1;
#pragma omp parallel for reduction(*:fac)
for(int n=2; n<=number;++n)
     fac *= n;
return fac;
}

//不用reduction，那么则需用适用atomic指令,但是这样一来，性能会大大的下降，因为这里没有使用局部变量，每个线程对fac的操作都需要进行同步。所以在这个例子中，并不会从多线程中受益多少，因为atomic成为了性能瓶颈。
int factorial(int number)
{
int fac =1;
#pragma omp parallel for
for(int n=2; n<=number;++n)
{
#pragma omp atomic
     fac *= n;
}
return fac;
}

//使用reduction指令的代码事实上类似于以下代码
int factorial(int number)
{
int fac =1;
#pragma omp parallel
{
int fac_private =1;
#pragma omp for nowait
for(int n=2; n<=number;++n)
       fac_private *= n;
#pragma omp atomic
     fac *= fac_private;
}
return fac;
}
```

* barrier

barrier指令是线程组中线程的一个同步点，只有线程组中的所有线程都到达这个位置之后，才会继续往下运行。而在每个for、section以及后面要讲到的single代码块最后都隐式的设置了barrier指令。

* nowait

nowait指令用来告诉编译器无需隐式调用barrier指令，因此如果为for、section、single设置了nowait标志，则在它们最后不会隐式的调用barrier指令

* single

single指令相关的代码块只运行一个线程执行，但并不限定具体哪一个线程来执行，其它线程必须跳过这个代码块，并在代码块后wait，直到执行这段代码的线程完成。

```cpp
#pragma omp parallel
{
   Work1();
#pragma omp single
{
     Work2();
}
   Work3();
}
//work1()和work3()会在线程组中所有线程都 运行一遍，但是work2()只会在一个线程中执行，即只会执行一遍。
```

* master

master指令则指定其相关的代码块必须在主线程中执行，且其它线程不必在代码块后阻塞

## 锁(mutex)

Mutex，互斥量，就是互斥访问的量。这种东东只在多线程编程中起作用，在单线程程序中是没有什么用处的。从c++11开始，c++提供了std::mutex类型，对于多线程的加锁操作提供了很好的支持。

**c++11中有4种锁类型**：

```text
- std::mutex，最基本的 Mutex 类。
- std::recursive_mutex，递归 Mutex 类。
- std::time_mutex，定时 Mutex 类。
- std::recursive_timed_mutex，定时递归 Mutex 类。
```

### std::mutex

std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁

`构造函数`:std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。

`lock()`:调用线程将锁住该互斥量。 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住；如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)

`unlock()`:解锁，释放对互斥量的所有权。

`try_lock()`:尝试锁住互斥量。如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉；如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)	

```cpp
#include <iostream>  // std::cout
#include <thread>   // std::thread
#include <mutex>   // std::mutex
 
volatile int counter(0); // non-atomic counter
std::mutex mtx;   // locks access to counter
 
void attempt_10k_increases() {
 for (int i=0; i<10000; ++i) {
  if (mtx.try_lock()) { // only increase if currently not locked:
   ++counter;
   mtx.unlock();
  }
 }
}
 
int main (int argc, const char* argv[]) {
 std::thread threads[10];
 for (int i=0; i<10; ++i)
  threads[i] = std::thread(attempt_10k_increases);
 
 for (auto& th : threads) th.join();
 std::cout << counter << " successful increases of the counter.\n";
 
 return 0;
}
```

### std::recursive_mutex

和 std::mutex 不同的是，std::recursive_mutex 允许**同一个线程**对互斥量**多次上锁**（即递归上锁），来获得对互斥量对象的多层所有权，std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()，可理解为 lock() 次数和 unlock() 次数相同，除此之外，std::recursive_mutex 的特性和 std::mutex 大致相同

### std::time_mutex

std::time_mutex 比 std::mutex 多了两个成员函数，try_lock_for()，try_lock_until()。

try_lock_for 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住,如果超时（即在指定时间内还是没有获得锁），则返回 false

try_lock_until 函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果超时（即在指定时间内还是没有获得锁），则返回 false。

```cpp
#include <iostream>  // std::cout
#include <chrono>   // std::chrono::milliseconds
#include <thread>   // std::thread
#include <mutex>   // std::timed_mutex
 
std::timed_mutex mtx;
void fireworks() {
 // waiting to get a lock: each thread prints "-" every 200ms:
 while (!mtx.try_lock_for(std::chrono::milliseconds(200))) {
 std::cout << "-";
 }
 // got a lock! - wait for 1s, then this thread prints "*"
 std::this_thread::sleep_for(std::chrono::milliseconds(1000));
 std::cout << "*\n";
 mtx.unlock();
}
int main ()
{
 std::thread threads[10];
 // spawn 10 threads:
 for (int i=0; i<10; ++i)
 threads[i] = std::thread(fireworks);
 
 for (auto& th : threads) th.join();
 return 0;
}
```

### std::recursive_timed_mutex

和 std:recursive_mutex 与 std::mutex 的关系一样

### 存在的问题

虽然std::mutex可以对多线程编程中的共享变量提供保护，但是直接使用std::mutex的情况并不多。因为仅使用std::mutex有时候会发生死锁。

考虑这样一个情况：假设线程1上锁成功，线程2上锁等待。但是线程1上锁成功后，抛出异常并退出，没有来得及释放锁，导致线程2“永久的等待下去”，此时就发生了死锁

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <mutex>
#include <chrono>
#include <stdexcept>

int counter = 0;
std::mutex mtx; // 保护counter

void increase_proxy(int time, int id) {
    for (int i = 0; i < time; i++) {
        mtx.lock();
        // 线程1上锁成功后，抛出异常：未释放锁
        if (id == 1) {
            throw std::runtime_error("throw excption....");
        }
        // 当前线程休眠1毫秒
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
        counter++;
        mtx.unlock();
    }
}
void increase(int time, int id) {
    try {
        increase_proxy(time, id);
    }
    catch (const std::exception& e){
        std::cout << "id:" << id << ", " << e.what() << std::endl;
    }
}
int main(int argc, char** argv) {
    std::thread t1(increase, 10000, 1);
    std::thread t2(increase, 10000, 2);
    t1.join();
    t2.join();
    std::cout << "counter:" << counter << std::endl;
    return 0;
}
```

为了避免出现以上这种情况，一般使用lock_guard或unique_lock两个类对mutex进行管理

### std::lock_guard

lock_guard 对象通常用于管理某个锁(Lock)对象；

在 lock_guard 对象构造时，传入的 Mutex 对象(即它所管理的 Mutex 对象)会被当前线程锁住。在lock_guard 对象被析构时，它所管理的 Mutex 对象会自动解锁，由于不需要程序员手动调用 lock 和 unlock 对 Mutex 进行上锁和解锁操作，因此这也是最简单安全的上锁和解锁方式，尤其是在程序抛出异常后先前已被上锁的 Mutex 对象可以正确进行解锁操作，极大地简化了程序员编写与 Mutex 相关的异常处理代码

值得注意的是，lock_guard 对象并不负责管理 Mutex 对象的生命周期，lock_guard 对象只是简化了 Mutex 对象的上锁和解锁操作，方便线程对互斥量上锁

`构造函数`:lock_guard 对象的拷贝构造和移动构造(move construction)均被禁用

```cpp
explicit lock_guard (mutex_type& m);  //lock_guard 对象管理 Mutex 对象 m，并在构造时对 m 进行上锁（调用 m.lock()）
lock_guard (mutex_type& m, adopt_lock_t tag); //lock_guard 对象管理 Mutex 对象 m,m 已被当前线程锁住
//tag有三个可选项
//std::adopt_lock  表明当前线程已经获得了锁，此后 mtx 对象的解锁操作交由 lock_guard 对象 lck 来管理，在 lck 的生命周期结束之后，mtx 对象会自动解锁。
//std::defer_lock  表明当前线程没有获得锁，后续需要去申请锁
//std::try_to_lock  表示创建对象的时候尝试去申请锁
lock_guard (const lock_guard&) = delete;  //拷贝构造被禁用
```

```cpp
#include <iostream>    // std::cout
#include <thread>     // std::thread
#include <mutex>     // std::mutex, std::lock_guard
#include <stdexcept>   // std::logic_error
 
std::mutex mtx;
void print_even (int x) {
 if (x%2==0) std::cout << x << " is even\n";
 else throw (std::logic_error("not even"));
}
 
void print_thread_id (int id) {
 try {
  // using a local lock_guard to lock mtx guarantees unlocking on destruction / exception:
  std::lock_guard<std::mutex> lck (mtx);
  print_even(id);
 }
 catch (std::logic_error&) {
  std::cout << "[exception caught]\n";
 }
} 
int main ()
{
 std::thread threads[10];
 // spawn 10 threads:
 for (int i=0; i<10; ++i)
  threads[i] = std::thread(print_thread_id,i+1);
 for (auto& th : threads) th.join();
 return 0;
}
```

### std::unique_lock

 lock_guard 最大的缺点也是简单，没有给程序员提供足够的灵活度。unique_lock，与 lock_guard 类相似，也很方便线程对互斥量上锁，但它提供了更好的上锁和解锁控制。

unique_lock 对象以独占所有权的方式（ unique owership）管理 mutex 对象的上锁和解锁操作，所谓独占所有权，就是没有其他的 unique_lock 对象同时拥有某个 mutex 对象的所有权

std::unique_lock 对象也能保证在其自身析构时它所管理的 Mutex 对象能够被正确地解锁（即使没有显式地调用 unlock 函数）。因此，和 lock_guard 一样，这也是一种简单而又安全的上锁和解锁方式，尤其是在程序抛出异常后先前已被上锁的 Mutex 对象可以正确进行解锁操作，极大地简化了程序员编写与 Mutex 相关的异常处理代码。

值得注意的是，unique_lock 对象同样也不负责管理 Mutex 对象的生命周期，unique_lock 对象只是简化了 Mutex 对象的上锁和解锁操作，方便线程对互斥量上锁

`构造函数`:

```cpp
unique_lock() noexcept;  //新创建的 unique_lock 对象不管理任何 Mutex 对象
explicit unique_lock(mutex_type& m);  //新创建的unique_lock对象管理Mutex对象m,并尝试调用m.lock()对 Mutex对象进行上锁
unique_lock(mutex_type& m, try_to_lock_t tag);//新创建的unique_lock对象管理Mutex对象 m，并尝试调用m.try_lock()对 Mutex对象进行上锁
unique_lock(mutex_type& m, defer_lock_t tag) noexcept;//新创建的 unique_lock 对象管理 Mutex 对象 m，但是在初始化的时候并不锁住 Mutex 对象
unique_lock(mutex_type& m, adopt_lock_t tag);//新创建的 unique_lock 对象管理 Mutex 对象 m， m 应该是一个已经被当前线程锁住的 Mutex 对象。
//新创建的 unique_lock 对象管理 Mutex 对象 m，并试图通过调用 m.try_lock_for(rel_time) 来锁住 Mutex 对象一段时间。
template <class Rep, class Period>
unique_lock(mutex_type& m, const chrono::duration<Rep,Period>& rel_time);
//新创建的 unique_lock 对象管理 Mutex 对象m，并试图通过调用 m.try_lock_until(abs_time)来在某个时间点之前锁住Mutex对象。
template <class Clock, class Duration>
unique_lock(mutex_type& m, const chrono::time_point<Clock,Duration>& abs_time);
unique_lock(const unique_lock&) = delete; //拷贝构造 [被禁用]
unique_lock(unique_lock&& x); //移动(move)构造
unique_lock& operator= (unique_lock&& x) noexcept;   //移动赋值
unique_lock& operator= (const unique_lock&) = delete; //普通赋值[被禁用]
```

```cpp
#include <iostream>    // std::cout
#include <thread>     // std::thread
#include <mutex>     // std::mutex, std::lock, std::unique_lock
             // std::adopt_lock, std::defer_lock
std::mutex foo,bar;
void task_a () {
 std::lock (foo,bar);     // simultaneous lock (prevents deadlock)
 std::unique_lock<std::mutex> lck1 (foo,std::adopt_lock);
 std::unique_lock<std::mutex> lck2 (bar,std::adopt_lock);
 std::cout << "task a\n";
 // (unlocked automatically on destruction of lck1 and lck2)
}
void task_b () {
 // foo.lock(); bar.lock(); // replaced by:
 std::unique_lock<std::mutex> lck1, lck2;
 lck1 = std::unique_lock<std::mutex>(bar,std::defer_lock); // move-assigned
 lck2 = std::unique_lock<std::mutex>(foo,std::defer_lock);
 std::lock (lck1,lck2);    // simultaneous lock (prevents deadlock)
 std::cout << "task b\n";
 // (unlocked automatically on destruction of lck1 and lck2)
}
int main ()
{
 std::thread th1 (task_a);
 std::thread th2 (task_b);
 th1.join();
 th2.join();
 return 0;
}
```

`成员函数`:

```text
上锁/解锁操作：lock，try_lock，try_lock_for，try_lock_until 和 unlock
修改操作：移动赋值(move assignment)(前面已经介绍过了)，交换(swap)（与另一个 std::unique_lock 对象交换它们所管理的 Mutex 对象的所有权），释放(release)（返回指向它所管理的 Mutex 对象的指针，并释放所有权）
获取属性操作：owns_lock（返回当前 std::unique_lock 对象是否获得了锁）、operator bool()（与 owns_lock 功能相同，返回当前 std::unique_lock 对象是否获得了锁）、mutex（返回当前 std::unique_lock 对象所管理的 Mutex 对象的指针）。
```

#### std::unique_lock::lock/std::unique_lock::unlock

```cpp
#include <iostream>    // std::cout
#include <thread>     // std::thread
#include <mutex>     // std::mutex, std::unique_lock, std::defer_lock
std::mutex mtx;      // mutex for critical section
void print_thread_id (int id) {
 std::unique_lock<std::mutex> lck (mtx,std::defer_lock);
 // critical section (exclusive access to std::cout signaled by locking lck):
 lck.lock();
 std::cout << "thread #" << id << '\n';
 lck.unlock();
}
int main ()
{
 std::thread threads[10];
 // spawn 10 threads:
 for (int i=0; i<10; ++i)
  threads[i] = std::thread(print_thread_id,i+1);
 
 for (auto& th : threads) th.join();
 
 return 0;
}
```

#### std::unique_lock::try_lock

```cpp
#include <iostream>    // std::cout
#include <vector>     // std::vector
#include <thread>     // std::thread
#include <mutex>     // std::mutex, std::unique_lock, std::defer_lock
 
std::mutex mtx;      // mutex for critical section
 
void print_star () {
 std::unique_lock<std::mutex> lck(mtx,std::defer_lock);
 // print '*' if successfully locked, 'x' otherwise: 
 if (lck.try_lock())
  std::cout << '*';
 else         
  std::cout << 'x';
}
 
int main ()
{
 std::vector<std::thread> threads;
 for (int i=0; i<500; ++i)
  threads.emplace_back(print_star);
 
 for (auto& x: threads) x.join();
 
 return 0;
}
```

#### std::unique_lock::try_lock_for

```cpp
#include <iostream>    // std::cout
#include <chrono>     // std::chrono::milliseconds
#include <thread>     // std::thread
#include <mutex>     // std::timed_mutex, std::unique_lock, std::defer_lock
 
std::timed_mutex mtx;
 
void fireworks () {
 std::unique_lock<std::timed_mutex> lck(mtx,std::defer_lock);
 // waiting to get a lock: each thread prints "-" every 200ms:
 while (!lck.try_lock_for(std::chrono::milliseconds(200))) {
  std::cout << "-";
 }
 // got a lock! - wait for 1s, then this thread prints "*"
 std::this_thread::sleep_for(std::chrono::milliseconds(1000));
 std::cout << "*\n";
}
 
int main ()
{
 std::thread threads[10];
 // spawn 10 threads:
 for (int i=0; i<10; ++i)
  threads[i] = std::thread(fireworks);
 
 for (auto& th : threads) th.join();
 
 return 0;
}
```

#### std::unique_lock::release

```cpp
//返回指向它所管理的 Mutex 对象的指针，并释放所有权。
#include <iostream>    // std::cout
#include <vector>     // std::vector
#include <thread>     // std::thread
#include <mutex>     // std::mutex, std::unique_lock
std::mutex mtx;
int count = 0;
void print_count_and_unlock (std::mutex* p_mtx) {
 std::cout << "count: " << count << '\n';
 p_mtx->unlock();
}
void task() {
 std::unique_lock<std::mutex> lck(mtx);
 ++count;
 print_count_and_unlock(lck.release());
}
int main ()
{
 std::vector<std::thread> threads;
 for (int i=0; i<10; ++i)
  threads.emplace_back(task);
 for (auto& x: threads) x.join();
 return 0;
}
```

#### std::unique_lock::owns_lock

```cpp
//返回当前 std::unique_lock 对象是否获得了锁
#include <iostream>    // std::cout
#include <vector>     // std::vector
#include <thread>     // std::thread
#include <mutex>     // std::mutex, std::unique_lock, std::try_to_lock
std::mutex mtx;      // mutex for critical section
void print_star () {
 std::unique_lock<std::mutex> lck(mtx,std::try_to_lock);
 // print '*' if successfully locked, 'x' otherwise: 
 if (lck.owns_lock())
  std::cout << '*';
 else         
  std::cout << 'x';
} 
int main ()
{
 std::vector<std::thread> threads;
 for (int i=0; i<500; ++i)
  threads.emplace_back(print_star);
 for (auto& x: threads) x.join();
 return 0;
}
```

#### std::unique_lock::operator bool()

```cpp
//与 owns_lock 功能相同，返回当前 std::unique_lock 对象是否获得了锁。
#include <iostream>    // std::cout
#include <vector>     // std::vector
#include <thread>     // std::thread
#include <mutex>     // std::mutex, std::unique_lock, std::try_to_lock
std::mutex mtx;      // mutex for critical section
void print_star () {
 std::unique_lock<std::mutex> lck(mtx,std::try_to_lock);
 // print '*' if successfully locked, 'x' otherwise: 
 if (lck)
  std::cout << '*';
 else         
  std::cout << 'x';
}
int main ()
{
 std::vector<std::thread> threads;
 for (int i=0; i<500; ++i)
  threads.emplace_back(print_star);
 for (auto& x: threads) x.join();
 return 0;
}
```

#### std::unique_lock::mutex

```cpp
//返回当前 std::unique_lock 对象所管理的 Mutex 对象的指针。
#include <iostream>    // std::cout
#include <thread>     // std::thread
#include <mutex>     // std::mutex, std::unique_lock, std::defer_lock
class MyMutex : public std::mutex {
 int _id;
public:
 MyMutex (int id) : _id(id) {}
 int id() {return _id;}
};
MyMutex mtx (101);
void print_ids (int id) {
 std::unique_lock<MyMutex> lck (mtx);
 std::cout << "thread #" << id << " locked mutex " << lck.mutex()->id() << '\n';
}
int main ()
{
 std::thread threads[10];
 // spawn 10 threads:
 for (int i=0; i<10; ++i)
  threads[i] = std::thread(print_ids,i+1);
 for (auto& th : threads) th.join();
 return 0;
}
```

### mutex函数

- std::try_lock，尝试同时对多个互斥量上锁。
- std::lock，可以同时对多个互斥量上锁。
- std::call_once，如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次



## reference

https://blog.csdn.net/acaiwlj/article/details/49818965

https://www.jb51.net/article/179681.htm