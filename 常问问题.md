### 1. 子类析构时要调用父类的析构函数吗

定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；

析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。

### 2. 多态，虚函数，纯虚函数，抽象类

**多态**：是对于不同对象接收相同消息时产生不同的动作。

C++的多态性具体体现在运行和编译两个方面：在程序运行时的多态性通过继承和虚函数来体现；在程序编译时多态性体现在函数和运算符的重载上；

**虚函数**：在基类中冠以关键字 virtual 的成员函数。子类可以（也可以不）重新定义基类的虚函数，该行为称之为复写Override。

子类如果不提供虚函数的实现，将会自动调用基类的缺省虚函数实现，作为备选方案；

虚函数实现的过程是：**通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用。**所以虚函数的调用时由指针所指向内存块的具体类型决定的。

当基类中的某个成员方法，在大多数情形下都应该由子类提供个性化实现，但基类也可以提供缺省备选方案的时候，该方法应该设计为虚函数。

**纯虚函数**：在虚函数后加“=0”，如 virtual void func()=0；如果一个类中至少有一个纯虚函数，那么这个类被称为**抽象类**（abstract class）

从基类继承来的纯虚函数，在子类中仍是虚函数。子类如果不实现纯虚函数，而只是继承基类的纯虚函数，则子类也是抽象类

子类如果实现了所有的纯虚函数，则子类非抽象类，可以用来创建对象；实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数。

作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在 纯虚函数不具备函数的功能，一般不能直接被调用。

当基类中的某个成员方法，必须由子类提供个性化实现的时候，应该设计为纯虚函数。

**抽象类**：带有纯虚函数的类为抽象类，抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为**接口**的操作。用户不能创建类的实例。但仍可使用指向抽象类的指针支持运行时多态性。

抽象类中不仅包括纯虚函数，也可包括虚函数

### 3. 构造函数和析构函数可以是虚函数吗？

构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。

首先，我们已经知道虚函数的实现则是通过对象内存中的vptr来实现的。而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。那么在构造函数完成之前，也即还没有进行初始化，此时vptr是没有值的，也就无法通过vptr找到作为构造函数和虚函数所在的代码区，所以构造函数只能以普通函数的形式存放在类所指定的代码区中。

而对于析构函数，当我们delete(a)的时候，如果析构函数不是虚函数，那么调用的将会是基类base的析构函数。而当继承的时候，通常派生类会在基类的基础上定义自己的成员，此时我们当然希望可以调用派生类的析构函数对新定义的成员也进行析构。

### 3. 重载（overload)和重写(overried）的区别

**重载**：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。

**重写**：是指子类重新定义父类虚函数的方法。和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）

### 4. C++是不是类型安全的

不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)

### 5. main 函数执行以前，还会执行什么代码

全局对象的构造函数会在main 函数之前执行

### 6. 描述内存分配方式以及它们的区别

C++程序内存由栈区、堆区、数据区（静态存储区）和程序代码区组成

1. 从静态存储区域分配。内存在程序**编译的时候**就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。

   初始化的全局变量和静态变量在一块区域(.data)，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域(.bss)

2. 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。

3. 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。

4. 代码区：存放CPU执行的机器指令，代码区是可共享，并且是只读的

5. 常量区：存放常量的区间，如字符串常量等，注意在常量区存放的数据一旦经初始化后就不能被修改。 程序结束后由系统释放

```cpp
int a = 0;          // 全局初始化区 
char *p1;         // 全局未初始化区
char s1[] = "abcdef"; //1） s1在静态区，"abcdef"无需额外存放，就是数组s1内部，总共占用一个串的内存
const char *p ="abcdef";//2）p在静态区,"abcdef",必须额外存放（在常量区，通常也在静态区），/总共占用一个指针，和一个串的内存

void main() 
{ 
  int b;            // 栈区
  char s[]="abcdef";//s是在栈区，“abcdef”在常量区，运行的时候复制给s，
  *s='w';//正确
  s[2]='w';//正确
  const char *p3 = "123456"; // p3在栈区，"123456"在常量区,其值不能被修改，指向常量的指针是不可以通过指针移动去修改指针所指内容的
  *p3='w';//错误,此区域是编译的时候确定的，并且程序结束的时候自动释放的， *p3= 'w';企图修改文字常量区引起错误
  char *p2;         // 栈区
  static int c =0;         // 全局（静态）初始化区 
  p1 = (char *)malloc(10); 
  p2 = (char *)malloc(20); // 分配得来的10和20字节的区域就在堆区 
  strcpy(p1, "123456");    // "123456" 放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方 
} 
```

### 7. static全局变量与普通的全局变量有什么区别？

全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同。这两者的区别在于作用域的扩展上。非静态的全局变量可以用extern扩展到组成源程序的多个文件中，而静态的全局变量的作用域只限于本文件，不能扩展到其它文件，由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。把全局变量改变为静态全局变量后是改变了它的作用域，限制了它的使用范围。

### 7. static函数与普通函数有什么区别？

static函数与普通函数作用域不同,仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件 

### 7. new 与malloc有什么区别

### 7. 请说出const与#define 相比，有何优点

const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。

1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。

2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。

### 8. 简述数组与指针的区别

数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。

### 9. 引用与指针有什么区别

1) 引用必须被初始化，指针不必。

2) 引用初始化以后不能被改变，指针可以改变所指的对象。

3) 不存在指向空值的引用，但是存在指向空值的指针。

### 10. 全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？

全局变量随主程序创建而创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；

使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。 

操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 

### 11. extern

### 12. register存储类型

声明为register的变量在由内存调入到CPU寄存器后，则常驻在CPU的寄存器中，因此访问register变量将在很大程度上提高效率，因为省去了变量由内存调入到寄存器过程中的好几个指令周期