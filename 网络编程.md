## 套接字（socket）

套接字是用来连接网络的工具；就好比电话是人与人之间沟通的工具。

套接字分为TCP套接字和UDP套接字。

## TCP套接字

1. 服务端

   ```cpp
   //1. 创建套接字
   int socket(int domain,int type, int protocol);
   //2. 给创建好的套接字分配地址信息（IP地址和端口号）
   int bind(int sockfd,struct sockaddr *myaddr,socklen_t addrlen);
   //3. 把套接字转化为可接收状态
   int listen(ubt sockfd,int backlog);
   //4. 处理连接
   int accept(int sockfd,struct *addr,socklen_t addrlen);
   //5. 断开连接
   int shutdown(int sockfd,int howto);
   ```

2. 客户端

   ```cpp
   // 1. 创建套接字
   int socket(int domain,int type, int protocol);
   // 2. 向服务器端发送连接请求
   int connect(int sockfd,struct sockaddr *serv_addr,socklen_t addrlen);
   ```




## 函数说明

```cpp
int socket(int domain,int type, int protocol);
// domain 套接字中的协议族信息
	// AF_INET		IPv4互联网协议族
	// AF_INET6		IPv6互联网协议族
	// AF_LOCAL		本地通信的UNIX协议族
	// AF_PACKET	底层套接字的协议族
	// AF_IPX		IPX Novell协议族
// type 套接字数据传输类型
	// SOCK_STREAM	面向连接的套接字  TCP
	// SOCK_DGRAM	面向消息的套接字  UDP
// protocol 计算机间通信中使用的协议信息
	//大部分情况下可以向该参数传递0；除非在同一协议族中存在多个数据传输方式相同的协议

int ss = socket(AF_INET, SOCK_STREAM, 0);  //TCP套接字，同int ss = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
int ss = socket(AF_INET, SOCK_DGRAM, 0);  //TCP套接字，同int ss = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
```



网络字节序为大端字节序，Intel主机为小端字节序，大小端转换函数如下：

```cpp
unsigned short htons(unsigned short); // host to network short,用于端口转换
unsigned short ntohs(unsigned short); // network to host short，用于端口转换
unsigned long htonl(unsigned long);  // host to network long，用于IP地址转换
unsigned long ntohl(unsigned long);  // network to host long，用于IP地址转换
```

除了向sockaddr_in结构体变量填充数据外，其他情况（数据发送和接收）无需考虑字节序问题。



```cpp
//将字符串类型的IP(201.211.214.36)转换为32位大端序整数型值，失败返回INADDR_NONE
//可以检测无效的IP地址
in_addr_t inet_addr(const char *ip);
//和inet_addr功能相同，只不过该函数利用了in_addr结构体
int inet_aton(const char *ip,struct in_addr *addr);
//将网络字节序IP地址转换成我们熟悉的字符串形式；失败时返回-1
//注意：返回是char指针，在下次调用该函数时会被覆盖，若要长期保存，则应将字符串复制到其他内存空间
char *inet_ntoa(struct in_addr addr);
```



网络地址信息初始化方法

```cpp
char * ip = "211.217.168.13";
int PORT = 9190;
struct sockaddr_in servaddr;
bzero(&servaddr, sizeof(servaddr));
servaddr.sin_family = AF_INET;
servaddr.sin_addr.s_addr = htonl(ip);
servaddr.sin_port = htons(PORT);
```

**INADDR_ANY**:服务端使用，用来自动获取运行服务器端的计算机IP地址



```cpp
int bind(int sockfd,struct sockaddr *myaddr,socklen_t addrlen);
// sockfd 要分配地址信息（IP和端口）的套接字文件描述符
// myaddr 存有地址信息的结构体变量地址
// addrlen 第二个结构体变量的长度
// 失败返回-1
```

```cpp
// 等待连接请求
int listen(int sockfd,int backlog);
// sockfd 套接字文件描述符
// backlog  连接请求队列的长度，若为，则队列长度为5，表示最多使5个连接请求进入队列
```

```cpp
// 受理客户端连接请求
// accept会创建一个新的socket和客户端的socket进行通行；服务器端的socket主要是负责管理请求队列。
int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);
// sockfd 服务器套接字文件描述符
// addr 保存发起连接请求的客户端地址信息的变量地址值，调用函数后向传递来的地址变量参数填充客户端地址信息
// addrlen 第二个参数addr结构体的长度
// 返回自动创建的用于数据IO的套接字的文件描述符；若等待队列为空，则accept不会返回，直到队列中出现新的客户端连接
```

```cpp
// 客户端向服务器端请求连接
// 在调用connect时，内核为客户端套接字添加IP和端口号（端口号是随机分配的），不需要手动调用bind去绑定
int connect(int sockfd,struct sockaddr *servaddr,socklen_t addrlen);
// sockfd 客户端套接字文件描述符
// servaddr  保存目标服务器端地址信息的变量地址值
// addrlen servaddr的长度
// 连接成功返回0，连接失败返回-1。（只要连接进入到服务端的等待队列中即算成功）
```

```cpp
// 断开连接
int shutdown(int sockfd,int howto);
// 成功时返回0，失败时返回-1
// sockfd 需要断开的套接字文件描述符
// howto 传递断开方式信息
//    SHUT_RD:断开输入流，清除输入缓冲区数据，同时无法调用输入相关函数
//    SHUT_WR:断开输出流，输出缓冲区若有数据，将数据传输至目标主机
//    SHUT_RDWR:同时断开IO流
```



TCP套接字缓冲区特性：

1. IO缓冲在每个TCP套接字中单独存在
2. IO缓冲在创建套接字时自动生成
3. 即使关闭套接字也会继续传递输出缓冲中遗留的数据
4. 关闭套接字将丢失输入缓冲中的数据

## UDP套接字

UDP不同于TCP，不存在请求连接和受理过程，因此在某种意义上无法明确区分服务器端和客户端。只是因其提供服务而称为服务器端。

```cpp
ssize_t sendto(int sockfd,void *buff,size_t nbytes,int flags,struct sockaddr *to,socklen_t addrlen);
// sockfd  用于传输数据的UDP套接字文件描述符
// buff  保存待传输数据的缓冲地址值
// nbytes  待传输的数据长度，以字节为单位
// flags  可选参数，没有则传递0
// to    存有目标地址信息的sockaddr结构体变量的地址值
// addrlen  传递给参数to的地址值结构体变量长度

//可以调用bind函数给UDP分配地址和端口
// 首次调用sendto函数时，如果尚未分配地址和端口，给相应套接字自动分配IP和端口，而且分配的地址一直保留到程序结束为止。
```



```cpp
ssize_t recvfrom(int sockfd,void *buff,size_t nbytes,int flags,struct sockaddr *from,socklen_t addrlen);
// sockfd  用于接收数据的UDP套接字文件描述符
// buff  保存接收数据的缓冲地址值
// nbytes  可接收的最大字节数
// flags  可选参数，没有则传递0
// to    存有发送端地址信息的sockaddr结构体变量的地址值
// addrlen  传递给参数from的地址值结构体变量长度
```

### connect UDP

UDP默认是unconnect的，即每次数据传输分为以下3个阶段：

1. 向UDP套接字注册目标IP和端口号
2. 传输数据
3. 删除UDP套接字中注册的目标地址信息

但是在UDP向同一目标主机发送多个数据时，以上1和3阶段不太合理，会降低UDP的性能，所以需要使用connect UDP来提高性能

```cpp
ssize_t connect(sockfd,struct sockaddr *to,socklen_t addrlen);
```

UDP套接字调用connect函数并不意味着要与对方UDP套接字连接，这只是向UDP套接字注册目标IP和端口信息。

调用connect指定了收发对象后，不仅可以使用sendto、recevfrom，还可以使用write、read函数进行通信。

## 域名

```cpp
//通过传递字符串格式的域名获取IP地址
struct hostent * gethostbyname(const char *hostname);
// 成功时返回hostent结构体地址，失败时返回NULL指针
struct hostent{
    char * h_name;  //official name，官方域名
    char ** h_aliases; //alias list,通过多个域名访问同一主页
    int h_addrtype;  //host address type，IP地址的地址族信息，IPv6/IPv4
    int h_length;  //address length,IP地址长度，IPv4为4，IPv6为16
    char ** h_addr_list;  //in_addr list，IP地址信息，可能有多个用于负载均衡
}
```

```cpp
//利用IP获取域名
struct hostent * gethostbyaddr(const char* addr,socklen_t len,int family);
// addr 含有IP地址信息的in_addr结构体指针
// len 向第一个参数传递的地址信息的字节数，IPv4为4，IPv6为16
// family 传递地址族信息，AF_INET,AF_INET6
```

