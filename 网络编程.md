## 套接字（socket）

套接字是用来连接网络的工具；就好比电话是人与人之间沟通的工具。

套接字分为TCP套接字和UDP套接字。

## TCP套接字

1. 服务端

   ```cpp
   //1. 创建套接字
   int socket(int domain,int type, int protocol);
   //2. 给创建好的套接字分配地址信息（IP地址和端口号）
   int bind(int sockfd,struct sockaddr *myaddr,socklen_t addrlen);
   //3. 把套接字转化为可接收状态
   int listen(ubt sockfd,int backlog);
   //4. 处理连接
   int accept(int sockfd,struct *addr,socklen_t addrlen);
   
   ```

2. 客户端

   ```cpp
   // 1. 创建套接字
   int socket(int domain,int type, int protocol);
   // 2. 向服务器端发送连接请求
   int connect(int sockfd,struct sockaddr *serv_addr,socklen_t addrlen);
   ```




## 函数说明

```cpp
int socket(int domain,int type, int protocol);
// domain 套接字中的协议族信息
	// AF_INET		IPv4互联网协议族
	// AF_INET6		IPv6互联网协议族
	// AF_LOCAL		本地通信的UNIX协议族
	// AF_PACKET	底层套接字的协议族
	// AF_IPX		IPX Novell协议族
// type 套接字数据传输类型
	// SOCK_STREAM	面向连接的套接字  TCP
	// SOCK_DGRAM	面向消息的套接字  UDP
// protocol 计算机间通信中使用的协议信息
	//大部分情况下可以向该参数传递0；除非在同一协议族中存在多个数据传输方式相同的协议

int ss = socket(AF_INET, SOCK_STREAM, 0);  //TCP套接字，同int ss = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
int ss = socket(AF_INET, SOCK_DGRAM, 0);  //TCP套接字，同int ss = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
```



网络字节序为大端字节序，Intel主机为小端字节序，大小端转换函数如下：

```cpp
unsigned short htons(unsigned short); // host to network short,用于端口转换
unsigned short ntohs(unsigned short); // network to host short，用于端口转换
unsigned long htonl(unsigned long);  // host to network long，用于IP地址转换
unsigned long ntohl(unsigned long);  // network to host long，用于IP地址转换
```

除了向sockaddr_in结构体变量填充数据外，其他情况（数据发送和接收）无需考虑字节序问题。



```cpp
//将字符串类型的IP(201.211.214.36)转换为32位大端序整数型值，失败返回INADDR_NONE
//可以检测无效的IP地址
in_addr_t inet_addr(const char *ip);
//和inet_addr功能相同，只不过该函数利用了in_addr结构体
int inet_aton(const char *ip,struct in_addr *addr);
//将网络字节序IP地址转换成我们熟悉的字符串形式；失败时返回-1
//注意：返回是char指针，在下次调用该函数时会被覆盖，若要长期保存，则应将字符串复制到其他内存空间
char *inet_ntoa(struct in_addr addr);
```



网络地址信息初始化方法

```cpp
char * ip = "211.217.168.13";
int PORT = 9190;
struct sockaddr_in servaddr;
bzero(&servaddr, sizeof(servaddr));
servaddr.sin_family = AF_INET;
servaddr.sin_addr.s_addr = htonl(ip);
servaddr.sin_port = htons(PORT);
```

**INADDR_ANY**:服务端使用，用来自动获取运行服务器端的计算机IP地址



```cpp
int bind(int sockfd,struct sockaddr *myaddr,socklen_t addrlen);
// sockfd 要分配地址信息（IP和端口）的套接字文件描述符
// myaddr 存有地址信息的结构体变量地址
// addrlen 第二个结构体变量的长度
// 失败返回-1
```

```cpp
// 等待连接请求
int listen(int sockfd,int backlog);
// sockfd 套接字文件描述符
// backlog  连接请求队列的长度，若为，则队列长度为5，表示最多使5个连接请求进入队列
```

```cpp
// 受理客户端连接请求
// accept会创建一个新的socket和客户端的socket进行通行；服务器端的socket主要是负责管理请求队列。
int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);
// sockfd 服务器套接字文件描述符
// addr 保存发起连接请求的客户端地址信息的变量地址值，调用函数后向传递来的地址变量参数填充客户端地址信息
// addrlen 第二个参数addr结构体的长度
// 返回自动创建的用于数据IO的套接字的文件描述符；若等待队列为空，则accept不会返回，直到队列中出现新的客户端连接
```

```cpp
// 客户端向服务器端请求连接
// 在调用connect时，内核为客户端套接字添加IP和端口号（端口号是随机分配的），不需要手动调用bind去绑定
int connect(int sockfd,struct sockaddr *servaddr,socklen_t addrlen);
// sockfd 客户端套接字文件描述符
// servaddr  保存目标服务器端地址信息的变量地址值
// addrlen servaddr的长度
// 连接成功返回0，连接失败返回-1。（只要连接进入到服务端的等待队列中即算成功）
```

